{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf390
{\fonttbl\f0\fnil\fcharset134 STSong;\f1\froman\fcharset0 Times-Roman;\f2\fnil\fcharset0 Georgia;
\f3\fswiss\fcharset0 Helvetica;\f4\fnil\fcharset0 Menlo-Regular;\f5\fswiss\fcharset0 ArialMT;
\f6\fnil\fcharset134 STHeitiSC-Light;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue233;\red255\green255\blue255;\red242\green242\blue242;
\red14\green14\blue14;\red208\green207\blue240;\red0\green0\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sa320
{\field{\*\fldinst{HYPERLINK "http://www.cnblogs.com/yishuiliunian/archive/2013/01/10/2855620.html"}}{\fldrslt 
\f0\fs48 \cf2 \cb3 \ul \ulc2 \'c0\'ed\'bd\'e2
\f1\b objective-c
\f0\b0 \'d4\'cb\'d0\'d0\'ca\'b1\'bb\'b7\'be\'b3\'a3\'a8\'b7\'ad\'d2\'eb\'a3\'a9\'b3\'f5\'b8\'e5}}
\f1\b\fs48 \cb3 \
\pard\pardeftab720\sl440\sa400

\f0\b0\fs40 \cf0 \cb4 \'d4\'ad\'ce\'c4\'b5\'d8\'d6\'b7\'a3\'ba{\field{\*\fldinst{HYPERLINK "http://cocoasamurai.blogspot.com/2010/01/understanding-objective-c-runtime.html"}}{\fldrslt 
\f2\b \cf2 \ul \ulc2 http://cocoasamurai.blogspot.com/2010/01/understanding-objective-c-runtime.html}}
\f2\b \
{\field{\*\fldinst{HYPERLINK "http://cocoasamurai.blogspot.com/2010/01/understanding-objective-c-runtime.html"}}{\fldrslt Understanding the Objective-C Runtime}}\
\pard\pardeftab720\sl440

\b0\fs26 \cf0 \
\pard\pardeftab720\sl440\qc

\f3\fs24 \cf0 \pard\pardeftab720\sl440\qc

\f2\fs26 \cf0 \
\pard\pardeftab720\sl440
\cf0 The Objective-C Runtime is one of the overlooked features of Objective-C initially when people are generally introduced to Cocoa/Objective-C. The reason for this is that while Objective-C (the language) is easy to pick up in only a couple hours, newcomers to Cocoa spend most of their time wrapping their heads around the Cocoa Framework and adjusting to how it works. However the runtime is something that everybody should at least know how it works in some detail beyond knowing that code like 
\f4\fs24 \cf5 \cb6 [target doMethodWith:var1];
\f2\fs26 \cf0 \cb4  gets translated into 
\f4\fs24 \cf5 \cb6 objc_msgSend(target,@selector(doMethodWith:),var1);
\f2\fs26 \cf0 \cb4  by the compiler. Knowing what the Objective-C runtime is doing will help you gain a much deeper understanding of Objective-C itself and how your app is run. I think Mac/iPhone Developers will gain something from this, regardless of your level of experience.\
Objective-C
\f0 \'d4\'cb\'d0\'d0\'ca\'b1\'b6\'d4\'d3\'da\'b8\'d5\'b8\'d5\'d1\'a7\'cf\'b0
\f2 cocoa/Objective-c
\f0 \'b5\'c4\'d0\'c2\'ca\'d6\'c0\'b4\'cb\'b5\'ca\'c7\'d2\'bb\'b8\'f6\'ba\'dc\'ba\'ea\'b9\'db\'b5\'c4\'bb\'f9\'b4\'a1\'cc\'d8\'d5\'f7\'a1\'a3\'d5\'e2\'b8\'f6\'d4\'ad\'d2\'f2\'ca\'c7
\f2 Ojbective-c
\f0 \'ca\'c7\'d2\'bb\'c3\'c5\'d4\'da\'bc\'b8\'b8\'f6\'d0\'a1\'ca\'b1\'d6\'ae\'c4\'da\'be\'cd\'bf\'c9\'d2\'d4\'d1\'a7\'bb\'e1\'b5\'c4\'d3\'ef\'d1\'d4\'a3\'ac\'b5\'ab\'ca\'c7\'b3\'f5\'d1\'a7\'d5\'df\'bd\'ab\'bb\'e1\'bb\'a8\'b7\'d1\'b4\'f3\'c1\'bf\'b5\'c4\'ca\'b1\'bc\'e4\'be\'c0\'bd\'e1\'d4\'da
\f2 Cocoa Framework
\f0 \'ba\'cd\'c5\'aa\'c3\'f7\'b0\'d7\'cb\'fb\'ca\'c7\'d4\'f5\'c3\'b4\'b9\'a4\'d7\'f7\'b5\'c4\'a1\'a3\'b5\'ab\'ca\'c7\'c3\'bf\'d2\'bb\'b8\'f6\'c8\'cb\'b6\'bc\'d6\'c1\'c9\'d9\'b5\'c3\'d6\'aa\'b5\'c0\'d4\'cb\'d0\'d0\'ca\'b1\'d4\'da\'cf\'b8\'bd\'da\'c9\'cf\'ca\'c7\'d4\'f5\'c3\'b4\'b9\'a4\'d7\'f7\'b5\'c4\'d2\'aa\'b3\'ac\'b9\'fd\'cf\'f1\'d5\'e2\'d1\'f9\'b5\'c4\'b4\'fa\'c2\'eb
\f2  [target doMethodWith:var1]
\f0 \'a3\'a8\'bf\'c9\'d2\'d4\'b1\'bb\'b1\'e0\'d2\'eb\'c6\'f7\'b7\'ad\'d2\'eb\'b3\'c9
\f2 objc_msgSend(target,@selector(doMethodWith:),var1);
\f0 \'a3\'a9\'c0\'ed\'bd\'e2\'d4\'cb\'d0\'d0\'ca\'b1\'bf\'c9\'d2\'d4\'b0\'ef\'d6\'fa\'c4\'e3\'b6\'d4
\f2 objective-c
\f0 \'d3\'d0\'d2\'bb\'b8\'f6\'b8\'fc\'c9\'ee\'b5\'c4\'c8\'cf\'ca\'b6\'a3\'ac\'b2\'a2\'c7\'d2\'d6\'aa\'b5\'c0\'d7\'d4\'bc\'ba\'b5\'c4\'b3\'cc\'d0\'f2\'ca\'c7\'d4\'f5\'d1\'f9\'d4\'ad\'d0\'cd\'b5\'c4\'a1\'a3\'ce\'d2\'cf\'eb
\f2 Mac/iphone
\f0 \'bf\'aa\'b7\'a2\'d5\'df\'bd\'ab\'c4\'dc\'b9\'bb\'b4\'d3\'d5\'e2\'c0\'ef\'bb\'f1\'c8\'a1\'ba\'dc\'b6\'e0\'b6\'ab\'ce\'f7\'a3\'ac\'ba\'f6\'c2\'d4\'b5\'f4\'c4\'e3\'b5\'c4\'be\'ad\'d1\'e9\'a1\'a3
\f2 \
\pard\pardeftab720\sl440

\b \cf0 The Objective-C Runtime is Open Source
\b0 \

\b Objective-c
\f0\b0 \'d4\'cb\'d0\'d0\'ca\'b1\'ca\'c7\'bf\'aa\'d4\'b4\'b5\'c4
\f2\b \
\pard\pardeftab720\sl440

\b0 \cf0 The Objective-C Runtime is open source and available anytime from {\field{\*\fldinst{HYPERLINK "http://opensource.apple.com/"}}{\fldrslt \cf7 http://opensource.apple.com}}. In fact examining the Objective-C is one of the first ways I went through to figure out how it worked, beyond reading Apples documentation on the matter. You can download the current version of the runtime (as of this writting) for Mac OS X 10.6.2 here {\field{\*\fldinst{HYPERLINK "http://opensource.apple.com/tarballs/objc4/objc4-437.1.tar.gz"}}{\fldrslt \cf7 objc4-437.1.tar.gz}}.\
Objective-c
\f0 \'d4\'cb\'d0\'d0\'ca\'b1\'ca\'c7\'d2\'bb\'bf\'aa\'d4\'b4\'b5\'c4\'a3\'ac\'b2\'a2\'c7\'d2\'bf\'c9\'d2\'d4\'b4\'d3
\f2  
\f0 \'bb\'f1\'b5\'c3\'a1\'a3\'ca\'b5\'bc\'ca\'c9\'cf\'b2\'e2\'ca\'d4
\f2 Objective-c
\f0 \'ca\'c7\'ce\'d2\'bd\'e2\'ca\'cd\'cb\'fc\'d4\'f5\'c3\'b4\'d4\'cb\'d0\'d0\'b5\'c4\'b5\'da\'d2\'bb\'d6\'d6\'b7\'bd\'b7\'a8\'a3\'ac\'d2\'aa\'b1\'c8\'d4\'c4\'b6\'c1\'c6\'b4\'b9\'fd\'b5\'c4\'ce\'c4\'b5\'b5\'d2\'aa\'ba\'c3\'a3\'ac\'d4\'da\'d5\'e2\'b8\'f6\'ce\'ca\'cc\'e2\'c9\'cf\'a1\'a3\'c4\'e3\'bf\'c9\'d2\'d4\'cf\'c2\'d4\'d8\'b5\'b1\'c7\'b0\'b0\'e6\'b1\'be\'b5\'c4\'d4\'cb\'d0\'d0\'ca\'b1\'a1\'a3
\f2 \
\pard\pardeftab720\sl440

\b \cf0 Dynamic vs Static Languages
\b0 \
\pard\pardeftab720\sl440

\f0 \cf0 \'b6\'af\'cc\'ac\'d3\'ef\'d1\'d4\'ba\'cd\'be\'b2\'cc\'ac\'d3\'ef\'d1\'d4\'b5\'c4\'b1\'c8\'bd\'cf
\f2 \
Objective-C is a runtime oriented language, which means that when it's possible it defers decisions about what will actually be executed from compile & link time to when it's actually executing on the runtime. This gives you a lot of flexibility in that you can redirect messages to appropriate objects as you need to or you can even intentionally swap method implementations, etc. This requires the use of a runtime which can introspect objects to see what they do & don't respond to and dispatch methods appropriately. If we contrast this to a language like C. In C you start out with a 
\f4\fs24 \cf5 \cb6 main()
\f2\fs26 \cf0 \cb4  method and then from there it's pretty much a top down design of following your logic and executing functions as you've written your code. A C struct can't forward requests to perform a function onto other targets. Pretty much you have a program like so\
Objective-c
\f0 \'ca\'c7\'d2\'bb\'b8\'f6\'d4\'cb\'d0\'d0\'ca\'b1\'b5\'c4\'c3\'e6\'cf\'f2\'b6\'d4\'cf\'f3\'b5\'c4\'d4\'b9\'d1\'d4\'a3\'ac\'d5\'e2\'d2\'e2\'ce\'b6\'d7\'c5\'cb\'fc\'bd\'ab\'d4\'da\'d4\'cb\'d0\'d0\'ca\'b1\'be\'f6\'b6\'a8\'d6\'b4\'d0\'d0\'ca\'b2\'c3\'b4\'b6\'f8\'b2\'bb\'ca\'c7\'d4\'da\'b1\'e0\'d2\'eb\'ca\'b1\'a1\'a3\'d5\'e2\'b8\'f8\'c1\'cb\'c4\'e3\'ba\'dc\'b4\'f3\'b5\'c4\'b1\'e3\'c0\'fb\'d0\'d4\'a3\'ac\'d6\'b1\'bd\'d3\'b0\'b4\'d5\'d5\'c4\'e3\'b5\'c4\'d0\'e8\'d2\'aa\'cf\'f2\'b6\'d4\'cf\'f3\'b7\'a2\'cb\'cd\'cf\'fb\'cf\'a2\'a1\'a3\'bb\'f2\'d5\'df\'c4\'e3\'c9\'f5\'d6\'c1\'bf\'c9\'d2\'d4\'b9\'ca\'d2\'e2\'b5\'c4\'b8\'c4\'b1\'e4\'b7\'bd\'b7\'a8\'ca\'b5\'cf\'d6\'b5\'c8\'b5\'c8\'a1\'a3\'a1\'a3\'a1\'a3\'d5\'e2\'d0\'e8\'d2\'aa\'b6\'d4\'c4\'dc\'b9\'bb\'b6\'d4\'b6\'d4\'cf\'f3\'c4\'da\'ca\'a1\'c0\'b4\'bf\'b4\'c6\'f0\'c4\'dc\'b9\'bb\'ba\'cd\'b2\'bb\'c4\'dc\'b9\'bb\'d6\'b4\'d0\'d0\'c4\'c4\'d0\'a9\'b7\'bd\'b7\'a8\'b2\'a2\'c7\'d2\'bd\'ab\'b7\'bd\'b7\'a8\'b7\'a2\'cb\'cd\'b8\'f8\'b6\'d4\'cf\'f3\'b5\'c4\'d4\'cb\'d0\'d0\'ca\'b1\'b5\'c4\'ca\'b9\'d3\'c3\'a1\'a3\'c8\'e7\'b9\'fb\'ce\'d2\'c3\'c7\'ba\'cd\'cf\'f1
\f2 C
\f0 \'d2\'bb\'d1\'f9\'b5\'c4\'d3\'ef\'d1\'d4\'b1\'c8\'bd\'cf\'a1\'a3\'ca\'b9\'d3\'c3
\f2 C
\f0 \'d3\'ef\'d1\'d4\'a3\'ac\'c4\'e3\'b4\'d3
\f2 main
\f0 \'a3\'a8\'a3\'a9\'b7\'bd\'b7\'a8\'bf\'aa\'ca\'bc\'a3\'ac\'c8\'bb\'ba\'f3\'cd\'ea\'c8\'ab\'bf\'b4\'d7\'c5\'c4\'e3\'c9\'e8\'bc\'c6\'b5\'c4\'c2\'df\'bc\'ad\'ba\'cd\'c4\'e3\'b5\'c4\'b4\'fa\'c2\'eb\'d7\'d4\'c9\'cf\'b6\'f8\'cf\'c2\'b5\'c4\'d6\'b4\'d0\'d0\'a1\'a3\'d2\'bb\'b8\'f6
\f2 c
\f0 \'bd\'e1\'b9\'b9\'cc\'e5\'b2\'bb\'c4\'dc\'d6\'b1\'bd\'d3\'b5\'c4\'bd\'b2\'d2\'bb\'b8\'f6\'ba\'af\'ca\'fd\'d4\'cb\'d0\'d0\'d4\'da\'d2\'bb\'b8\'f6\'b6\'d4\'cf\'f3\'c9\'cf\'a1\'a3\'be\'cd\'cf\'f1\'d5\'e2\'b8\'f6\'b3\'cc\'d0\'f2\'a3\'ba
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 #include < stdio.h >\
 \
int main(int argc, const char **argv[])\
\{\
        printf("Hello World!");\
        return 0;\
\} \
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 which a compiler parses, optimizes and then transforms your optimized code into assembly\

\f0 \'b1\'e0\'d2\'eb\'c6\'f7\'d3\'ef\'b7\'a8\'b7\'d6\'ce\'f6\'a3\'ac\'d3\'c5\'bb\'af\'c8\'bb\'ba\'f3\'bd\'ab\'c4\'e3\'d7\'ee\'bc\'d1\'bb\'af\'b5\'c4\'b4\'fa\'c2\'eb\'b7\'ad\'d2\'eb\'b3\'c9\'bb\'e3\'b1\'e0\'d3\'ef\'d1\'d4
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 .text\
 .align 4,0x90\
 .globl _main\
_main:\
Leh_func_begin1:\
 pushq %rbp\
Llabel1:\
 movq %rsp, %rbp\
Llabel2:\
 subq $16, %rsp\
Llabel3:\
 movq %rsi, %rax\
 movl %edi, %ecx\
 movl %ecx, -8(%rbp)\
 movq %rax, -16(%rbp)\
 xorb %al, %al\
 leaq LC(%rip), %rcx\
 movq %rcx, %rdi\
 call _printf\
 movl $0, -4(%rbp)\
 movl -4(%rbp), %eax\
 addq $16, %rsp\
 popq %rbp\
 ret\
Leh_func_end1:\
 .cstring\
LC:\
 .asciz "Hello World!"\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 and then links it together with a library and produces a executable. This contrasts from Objective-C in that while the process is similar the code that the compiler generates depends on the presence of the Objective-C Runtime Library. When we are all initially introduced to Objective-C we are told that (at a simplistic level) what happens to our Objective-C bracket code is something like\'85\

\f0 \'c8\'bb\'ba\'f3\'bd\'ab\'bf\'e2\'ba\'cd\'cb\'fc\'c1\'b4\'bd\'d3\'c6\'f0\'c0\'b4\'a3\'ac\'b2\'fa\'c9\'fa\'d2\'bb\'b8\'f6\'bf\'c9\'d6\'b4\'d0\'d0\'ce\'c4\'bc\'fe\'a1\'a3\'d5\'e2\'ba\'cd
\f2 Objective-C
\f0 \'cf\'e0\'b1\'c8\'d2\'c0\'c0\'b5
\f2 Objective-C
\f0 \'bf\'e2\'b5\'c4\'b1\'e0\'d2\'eb\'c6\'f7\'b2\'fa\'c9\'fa\'c1\'cb\'cf\'e0\'cd\'ac\'b5\'c4\'b4\'fa\'c2\'eb\'a1\'a3\'b5\'b1\'ce\'d2\'c3\'c7\'b8\'d5\'bf\'aa\'ca\'bc\'bd\'d3\'b4\'a5
\f2 Objective-C
\f0 \'b5\'c4\'ca\'b1\'ba\'f2\'a3\'ac\'ce\'d2\'c3\'c7\'b1\'bb\'b8\'e6\'cb\'df\'cf\'f1\'d5\'e2\'d1\'f9\'b1\'bb\'d6\'d0\'c0\'a8\'ba\'c5\'b0\'fc\'b9\'fc\'b5\'c4
\f2 Objective-C
\f0 \'b4\'fa\'c2\'eb
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 [self doSomethingWithVar:var1];\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 gets translated to\'85\

\f0 \'b1\'bb\'b7\'ad\'d2\'eb\'b3\'c9
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 objc_msgSend(self,@selector(doSomethingWithVar:),var1);\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 but beyond this we don't really know much till much later on what the runtime is doing.\

\f0 \'b5\'ab\'ca\'c7\'b3\'ac\'b9\'fd\'d5\'e2\'a3\'ac\'ca\'b5\'bc\'ca\'c9\'cf\'ce\'d2\'c3\'c7\'b2\'a2\'b2\'bb\'d6\'aa\'b5\'c0\'d6\'ae\'ba\'f3\'d4\'cb\'d0\'d0\'ca\'b1\'d7\'f6\'c1\'cb\'d0\'a9\'ca\'b2\'c3\'b4\'a1\'a3
\f2 \
\pard\pardeftab720\sl440

\b \cf0 What is the Objective-C Runtime?
\b0 \
\pard\pardeftab720\sl440

\f0 \cf0 \'ca\'b2\'c3\'b4\'ca\'c7
\f2 Objective-C
\f0 \'d4\'cb\'d0\'d0\'ca\'b1\'bb\'b7\'be\'b3\'a3\'bf
\f2 \
The Objective-C Runtime is a Runtime Library, it's a library written mainly in C & Assembler that adds the Object Oriented capabilities to C to create Objective-C. This means it loads in Class information, does all method dispatching, method forwarding, etc. The Objective-C runtime essentially creates all the support structures that make Object Oriented Programming with Objective-C Possible.\
\pard\pardeftab720\sl440

\b \cf0 Objective-C
\f0\b0 \'d4\'cb\'d0\'d0\'ca\'b1\'ca\'c7\'d2\'bb\'b8\'f6\'d4\'cb\'d0\'d0\'ca\'b1\'bf\'e2\'a1\'a3\'a3\'ac\'d5\'e2\'ca\'c7\'d2\'bb\'b8\'f6\'d3\'c3
\f2\b C
\f0\b0 \'ba\'cd\'bb\'e3\'b1\'e0\'d0\'b4\'b5\'c4\'bf\'e2\'a3\'ac\'ce\'aa\'c1\'cb\'b8\'f8
\f2\b C
\f0\b0 \'d3\'ef\'d1\'d4\'cc\'e1\'b9\'a9\'c3\'e6\'cf\'f2\'b6\'d4\'cf\'f3\'b5\'c4\'c4\'dc\'b9\'bb\'a3\'ac\'d2\'d4\'b4\'b4\'d4\'ec
\f2\b Objective-C
\f0\b0 \'a1\'a3\'d5\'e2\'d2\'e2\'ce\'b6\'cb\'fc\'bc\'d3\'d4\'d8\'c0\'e0\'d0\'c5\'cf\'a2\'a3\'ac\'b7\'d6\'c5\'e4\'b7\'bd\'b7\'a8\'a3\'ac\'d6\'b4\'d0\'d0\'b7\'bd\'b7\'a8\'b5\'c8\'b5\'c8\'a1\'a3
\f2\b Objective-c
\f0\b0 \'d6\'f7\'d2\'aa\'cc\'e1\'b9\'a9\'c1\'cb\'c8\'c3
\f2\b Objective-C
\f0\b0 \'c3\'e6\'cf\'f2\'b6\'d4\'cf\'f3\'b5\'c4\'c4\'dc\'c1\'a6\'a1\'a3
\f2 \
\

\b Objective-C Runtime Terminology
\b0 \
Ojbective-C 
\f0 \'d4\'cb\'d0\'d0\'ca\'b1\'ca\'f5\'d3\'ef
\f2 \
So before we go on much further, let's get some terminology out of the way so we are all on the same page about everything. 2 Runtimes As far as Mac & iPhone Developers are concerned there are 2 runtimes: The Modern Runtime & the Legacy Runtime Modern Runtime: Covers all 64 bit Mac OS X Apps & all iPhone OS Apps Legacy Runtime: Covers everything else (all 32 bit Mac OS X Apps) Method There are 2 basic types of methods. Instance Methods (begin with a '-' like 
\f4\fs24 \cf5 \cb6 -(void)doFoo;
\f2\fs26 \cf0 \cb4  that operate on Object Instances. And Class Methods (begin with a '+' like 
\f4\fs24 \cf5 \cb6 + (id)alloc
\f2\fs26 \cf0 \cb4 . Methods are just like C Functions in that they are a grouping of code that performs a small task like\
\pard\pardeftab720\sl440

\f0 \cf0 \'d3\'da\'ca\'c7\'d4\'da\'ce\'d2\'c3\'c7\'b8\'fc\'bd\'f8\'d2\'bb\'b2\'bd\'d6\'ae\'c7\'b0\'a3\'ac\'ce\'d2\'c3\'c7\'cf\'c8\'c1\'cb\'bd\'e2\'d2\'bb\'d0\'a9\'d4\'da\'d5\'e2\'b8\'f6\'d2\'b3\'c3\'e6\'d6\'d0\'b3\'f6\'cf\'d6\'b5\'c4\'bb\'f9\'b1\'be\'ca\'f5\'d3\'ef\'a1\'a3\'b6\'d4\'d3\'da
\f2 Mac
\f0 \'ba\'cd
\f2 Iphone
\f0 \'bf\'aa\'b7\'a2\'d5\'df\'b6\'f8\'d1\'d4\'d3\'d0\'c1\'bd\'b8\'f6\'d4\'cb\'d0\'d0\'ca\'b1\'bb\'b7\'be\'b3\'a3\'ba\'cf\'d6\'b4\'fa\'d4\'cb\'d0\'d0\'ca\'b1\'bb\'b7\'be\'b3\'ba\'cd\'d2\'c5\'c1\'f4\'cf\'c2\'c0\'b4\'b5\'c4\'d4\'cb\'d0\'d0\'ca\'b1\'bb\'b7\'be\'b3\'a3\'ac\'ba\'ad\'b8\'c7
\f2 64
\f0 \'ce\'bb
\f2 Mac OS X
\f0 \'b3\'cc\'d0\'f2\'ba\'cd\'cb\'f9\'d3\'d0
\f2 Iphone OS
\f0 \'b3\'cc\'d0\'f2\'b5\'c4\'d2\'c5\'c1\'f4\'cf\'c2\'c0\'b4\'b5\'c4\'d4\'cb\'d0\'d0\'ca\'b1\'bb\'b7\'be\'b3\'a3\'ac\'ba\'ad\'b8\'c7\'cb\'f9\'d3\'d0\'b3\'cc\'d0\'f2\'a1\'a3\'d5\'e2\'c0\'ef\'d3\'d0\'c1\'bd\'b8\'f6\'d6\'d6\'bb\'f9\'b1\'be\'b5\'c4\'b7\'bd\'b7\'a8\'a1\'a3
\f2  
\f0 \'ca\'b5\'c0\'fd\'b7\'bd\'b7\'a8\'a3\'a8\'d2\'d4
\f2 \'93-\'94
\f0 \'bf\'aa\'ca\'bc\'a3\'a9\'a3\'ac\'d2\'bb\'b8\'f6\'d7\'f7\'d3\'c3\'d3\'da\'b6\'d4\'cf\'f3\'ca\'b5\'c0\'fd\'b5\'c4\'b6\'af\'d7\'f7\'a1\'a3\'bb\'b9\'d3\'d0\'c0\'e0\'b7\'bd\'b7\'a8\'a3\'a8\'d2\'d4
\f2 \'93+\'94
\f0 \'bf\'aa\'ca\'bc\'a3\'a9\'a1\'a3\'d5\'e2\'d6\'d6\'b7\'bd\'b7\'a8\'be\'cd\'cf\'f1
\f2 C
\f0 \'b7\'bd\'b7\'a8\'d2\'bb\'d1\'f9\'ca\'c7\'d2\'bb\'b6\'ce\'b4\'fa\'c2\'eb\'b5\'c4\'bd\'e1\'ba\'cf\'d2\'bb\'cd\'ea\'b3\'c9\'d2\'bb\'b8\'f6\'bc\'f2\'b5\'a5\'b5\'c4\'c8\'ce\'ce\'f1\'a3\'ac\'b1\'c8\'c8\'e7
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 -(NSString *)movieTitle\
\{\
    return @"Futurama: Into the Wild Green Yonder";\
\}\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 Selector A selector in Objective-C is essentially a C data struct that serves as a mean to identify an Objective-C method you want an object to perform. In the runtime it's defined like so\'85\

\f0 \'d1\'a1\'d4\'f1\'c6\'f7
\f2 A 
\f0 \'d1\'a1\'d4\'f1\'c6\'f7\'d4\'da
\f2 Objective-C
\f0 \'d6\'d0\'ca\'c7\'d2\'bb\'b8\'f6\'d6\'d8\'d2\'aa\'b5\'c4
\f2 C
\f0 \'ca\'fd\'be\'dd\'bd\'e1\'b9\'b9\'cc\'e1\'b9\'a9\'c1\'cb\'b1\'e6\'ca\'b6\'be\'df\'cc\'e5\'b5\'c4
\f2 Objective-C
\f0 \'b7\'bd\'b7\'a8\'d4\'da\'c4\'e3\'d0\'e8\'d2\'aa\'b5\'c4\'b6\'d4\'cf\'f3\'c9\'cf\'d6\'b4\'d0\'d0\'b5\'c4\'b7\'bd\'b7\'a8\'a1\'a3\'d4\'da\'d4\'cb\'d0\'d0\'ca\'b1\'d5\'e2\'b8\'f6\'b6\'a8\'d2\'e5\'cf\'f1\'a3\'ba
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 typedef struct objc_selector  *SEL; \
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 and used like so\'85\

\f0 \'b2\'a2\'c7\'d2\'ca\'b9\'d3\'c3\'ca\'b1\'cf\'f1
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 SEL aSel = @selector(movieTitle); \
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 Message\

\f0 \'cf\'fb\'cf\'a2
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 [target getMovieTitleForObject:obj];\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 An Objective-C Message is everything between the 2 brackets '[ ]' and consists of the target you are sending a message to, the method you want it to perform and any arguments you are sending it. A Objective-C message while similar to a C function call is different. The fact that you send a message to an object doesn't mean that it'll perform it. The Object could check who the sender of the message is and based on that decide to perform a different method or forward the message onto a different target object. Class If you look in the runtime for a class you'll come across this\'85\

\f0 \'d2\'bb\'b8\'f6
\f2 Objective-C
\f0 \'cf\'fb\'cf\'a2\'ca\'c7\'d4\'da
\f2 []
\f0 \'d6\'ae\'bc\'e4\'b5\'c4\'cb\'f9\'d3\'d0\'b6\'ab\'ce\'f7\'a3\'ac\'cb\'fc\'d3\'c9\'c4\'e3\'d2\'aa\'b7\'a2\'cb\'cd\'cf\'fb\'cf\'a2\'b5\'c4\'b6\'d4\'cf\'f3\'ba\'cd\'c4\'e3\'d2\'aa\'d6\'b4\'d0\'d0\'b5\'c4\'b7\'bd\'b7\'a8\'d2\'d4\'bc\'b0\'c4\'e3\'d2\'aa\'b7\'a2\'cb\'cd\'b5\'c4\'b2\'ce\'ca\'fd\'d7\'e9\'b3\'c9\'a1\'a3\'d2\'bb\'b8\'f6
\f2 Objective-C
\f0 \'cf\'fb\'cf\'a2\'d3\'eb
\f2 C
\f0 \'ba\'af\'ca\'fd\'b5\'f7\'d3\'c3\'cf\'e0\'b1\'c8\'ca\'c7\'b2\'bb\'cd\'ac\'b5\'c4\'a1\'a3\'ca\'b5\'bc\'ca\'c9\'cf\'c4\'e3\'b7\'a2\'cb\'cd\'c1\'cb\'d2\'bb\'b8\'f6\'cf\'fb\'cf\'a2\'b8\'f8\'d2\'bb\'b8\'f6\'b6\'d4\'cf\'f3\'b2\'a2\'b2\'bb\'d2\'e2\'ce\'b6\'d7\'c5\'d5\'e2\'b8\'f6\'b6\'d4\'cf\'f3\'bb\'e1\'d6\'b4\'d0\'d0\'d5\'e2\'b8\'f6\'b7\'bd\'b7\'a8\'a1\'a3\'b6\'d4\'cf\'f3\'bd\'ab\'bb\'e1\'bc\'ec\'b3\'b5\'cb\'ad\'ca\'c7\'d5\'e2\'b8\'f6\'d5\'e2\'d0\'a1\'b5\'c4\'b7\'a2\'cb\'cd\'d5\'df\'c8\'bb\'ba\'f3\'be\'f6\'b6\'a8\'ca\'c7\'d6\'b4\'d0\'d0\'d2\'bb\'b8\'f6\'b1\'f0\'b5\'c4\'b7\'bd\'b7\'a8\'bb\'b9\'ca\'c7\'b4\'ab\'b5\'dd\'d5\'e2\'b8\'f6\'cf\'fb\'cf\'a2\'b8\'f8\'c6\'e4\'cb\'fb\'b5\'c4\'b6\'d4\'cf\'f3\'a1\'a3\'c8\'e7\'b9\'fb\'c4\'e3\'b9\'db\'b2\'ec\'c0\'e0\'d4\'da\'d4\'cb\'d0\'d0\'ca\'b1\'b5\'c4\'c7\'e9\'bf\'f6\'a3\'ac\'c4\'e3\'bd\'ab\'bb\'e1\'b7\'a2\'cf\'d6
\f2 \'a0\'a0\
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 typedef struct objc_class *Class;\
typedef struct objc_object \{\
    Class isa;\
\} *id; \
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 Here there are several things going on. We have a struct for an Objective-C Class and a struct for an object. All the objc_object has is a class pointer defined as isa, this is what we mean by the term 'isa pointer'. This isa pointer is all the Objective-C Runtime needs to inspect an object and see what it's class is and then begin seeing if it responds to selectors when you are messaging objects. And lastly we see the id pointer. The id pointer by default tells us nothing about Objective-C objects except that they are Objective-C objects. When you have a id pointer you can then ask that object for it's class, see if it responds to a method, etc and then act more specifically when you know what the object is that you are pointing to. You can see this as well on Blocks in the LLVM/Clang docs\

\f0 \'ba\'dc\'c3\'f7\'cf\'d4\'d5\'e2\'c0\'ef\'d3\'d0\'ba\'dc\'b6\'e0\'b6\'ab\'ce\'f7\'d5\'fd\'d4\'da\'bd\'f8\'d0\'d0\'a1\'a3\'ce\'d2\'c3\'c7\'d3\'d0\'d2\'bb\'b8\'f6
\f2 Objective-C
\f0 \'b5\'c4\'ca\'fd\'be\'dd\'bd\'e1\'b9\'b9\'a1\'a3\'cb\'f9\'d3\'d0\'b5\'c4
\f2 objc
\f0 \'b6\'d4\'cf\'f3\'d3\'d0\'d2\'bb\'b8\'f6
\f2 ISA
\f0 \'b5\'c4\'c0\'e0\'d6\'b8\'d5\'eb\'a1\'a3\'d5\'e2\'be\'cd\'ca\'c7\'ce\'d2\'c3\'c7\'d3\'c3
\f2 \'93isa pointer\'94
\f0 \'cb\'f9\'c3\'e8\'ca\'f6\'b5\'c4\'a1\'a3
\f2  ISA
\f0 \'d6\'b8\'d5\'eb\'ca\'c7\'cb\'f9\'d3\'d0
\f2 Ojective-c
\f0 \'d4\'cb\'d0\'d0\'ca\'b1\'cb\'f9\'d0\'e8\'d2\'aa\'b5\'c4\'a3\'ac\'c8\'a5\'b1\'e6\'b1\'f0\'b6\'d4\'cf\'f3\'a3\'ac\'ba\'cd\'b6\'d4\'cf\'f3\'c0\'e0\'d0\'cd\'c8\'bb\'ba\'f3\'c5\'d0\'b6\'cf\'c6\'e4\'ca\'c7\'b7\'f1\'b6\'d4\'d2\'bb\'b8\'f6\'d1\'a1\'d4\'f1\'c6\'f7\'d3\'d0\'cf\'ec\'d3\'a6\'b5\'b1\'c4\'e3\'b7\'a2\'cb\'cd\'d0\'a1\'ca\'b1\'ca\'b1\'a1\'a3\'c8\'bb\'ba\'f3\'ce\'d2\'c3\'c7\'bf\'b4\'b5\'bd\'c1\'cb\'b6\'d4\'cf\'f3\'d6\'b8\'d5\'eb\'a1\'a3\'b6\'d4\'cf\'f3\'d6\'b8\'d5\'eb\'c4\'ac\'c8\'cf\'c3\'bb\'d3\'d0\'b8\'e6\'cb\'df\'ce\'d2\'c8\'ce\'ba\'ce\'b6\'ab\'ce\'f7\'a3\'ac\'b3\'fd\'c1\'cb\'d5\'e2\'ca\'c7\'b8\'f6
\f2 Objective-C
\f0 \'b6\'d4\'cf\'f3\'d6\'ae\'cd\'e2\'a1\'a3\'b5\'b1\'c4\'e3\'d3\'d0\'d2\'bb\'b8\'f6\'b6\'d4\'cf\'f3\'d6\'b8\'d5\'eb\'a3\'ac\'c4\'e3\'bf\'c9\'d2\'d4\'d1\'af\'ce\'ca\'d5\'e2\'b8\'f6\'b6\'d4\'cf\'f3\'b5\'c4\'c0\'e0\'d0\'cd\'a3\'ac\'bc\'ec\'b2\'e9\'ca\'c7\'b7\'f1\'cf\'ec\'d3\'a6\'c4\'b3\'b8\'f6\'b7\'bd\'b7\'a8\'b5\'c8\'b5\'c8\'a3\'ac\'c8\'bb\'ba\'f3\'d6\'b4\'d0\'d0\'b5\'b1\'c4\'e3\'d6\'aa\'b5\'c0\'d5\'e2\'b8\'f6\'d6\'b8\'d5\'eb\'d6\'b8\'cf\'f2\'b5\'c4\'ca\'c7\'d2\'bb\'b8\'f6\'ca\'b2\'c3\'b4\'b6\'d4\'cf\'f3\'a1\'a3\'c4\'e3\'c4\'dc\'b7\'a2\'cf\'d6\'cd\'ac\'d1\'f9\'b5\'c4\'b6\'ab\'ce\'f7\'b9\'d8\'d3\'da
\f2 Blocks
\f0 \'d4\'da
\f2 LLVM/CLang
\f0 \'ce\'c4\'b5\'b5\'d6\'d0\'a1\'a3
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 struct Block_literal_1 \{\
    void *isa; // initialized to &_NSConcreteStackBlock or &_NSConcreteGlobalBlock\
    int flags;\
    int reserved; \
    void (*invoke)(void *, ...);\
    struct Block_descriptor_1 \{\
 unsigned long int reserved; // NULL\
     unsigned long int size;  // sizeof(struct Block_literal_1)\
 // optional helper functions\
     void (*copy_helper)(void *dst, void *src);\
     void (*dispose_helper)(void *src); \
    \} *descriptor;\
    // imported variables\
\}; \
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 Blocks themselves are designed to be compatible with the Objective-C runtime so they are treated as objects so they can respond to messages like 
\f4\fs24 \cf5 \cb6 -retain
\f2\fs26 \cf0 \cb4 ,
\f4\fs24 \cf5 \cb6 -release
\f2\fs26 \cf0 \cb4 ,
\f4\fs24 \cf5 \cb6 -copy
\f2\fs26 \cf0 \cb4 ,etc. IMP (Method Implementations)\
Block
\f0 \'b1\'bb\'c9\'e8\'bc\'c6\'b3\'c9\'c4\'dc\'b9\'bb\'d3\'eb
\f2 Objective-C
\f0 \'d4\'cb\'d0\'d0\'ca\'b1\'bd\'e1\'ba\'cf\'a3\'ac\'b7\'bd\'b1\'e3\'b0\'d1\'cb\'fb\'c3\'c7\'b5\'b1\'b3\'c9\'b6\'d4\'cf\'f3\'b4\'a6\'c0\'ed\'a3\'ac\'d2\'d4\'ca\'b9\'cb\'fb\'c3\'c7\'c4\'dc\'b9\'bb\'cf\'e0\'d3\'a6\'d5\'e2\'d0\'a9\'cf\'fb\'cf\'a2\'a1\'a3
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 typedef id (*IMP)(id self,SEL _cmd,...); \
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 IMP's are function pointers to the method implementations that the compiler will generate for you. If your new to Objective-C you don't need to deal with these directly until much later on, but this is how the Objective-C runtime invokes your methods as we'll see soon. Objective-C Classes So what's in an Objectve-C Class? The basic implementation of a class in Objective-C looks like\
IMP
\f0 \'ca\'c7\'b1\'e0\'d2\'eb\'c6\'f7\'bd\'ab\'bb\'e1\'b2\'fa\'c9\'fa\'b8\'f8\'c4\'e3\'b5\'c4\'ba\'af\'ca\'fd\'d6\'b8\'d5\'eb\'a1\'a3\'c8\'e7\'b9\'fb\'c4\'e3\'b8\'d5\'bd\'d3\'b4\'a5
\f2 Objective-C
\f0 \'a3\'ac\'c4\'e3\'b2\'bb\'d3\'c3\'d6\'b1\'bd\'d3\'b4\'a6\'c0\'ed\'d5\'e2\'d0\'a9\'d6\'aa\'b5\'c0\'ba\'dc\'b3\'a4\'d2\'bb\'b6\'ce\'ca\'b1\'bc\'e4\'d6\'ae\'ba\'f3\'a3\'ac\'b5\'ab\'ca\'c7\'d5\'e2\'ca\'c7
\f2 Objective-C
\f0 \'d4\'cb\'d0\'d0\'ca\'b1\'cf\'f1\'c4\'e3\'bf\'b4\'b5\'bd\'b5\'c4\'d2\'bb\'d1\'f9\'d6\'ae\'d0\'d0\'c4\'e3\'b5\'c4\'b7\'bd\'b7\'a8\'b5\'c4\'bb\'f9\'b4\'a1\'ca\'b5\'cf\'d6\'a1\'a3\'b6\'d4\'d3\'da
\f2 Objective-C
\f0 \'c0\'e0\'c0\'b4\'cb\'b5\'ca\'b2\'c3\'b4\'ca\'c7\'d2\'bb\'b8\'f6
\f2 Objetive-C
\f0 \'b5\'c4\'c0\'e0\'c4\'d8\'a3\'bf\'d2\'bb\'b8\'f6
\f2 Objective-C
\f0 \'b5\'c4\'c0\'db\'b5\'c4\'bb\'f9\'b4\'a1\'ca\'b5\'cf\'d6\'cf\'f1\'d5\'e2\'d1\'f9\'a3\'ba
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 @interface MyClass : NSObject \{\
//vars\
NSInteger counter;\
\}\
//methods\
-(void)doFoo;\
@end\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 but the runtime has more than that to keep track of\

\f0 \'b5\'ab\'ca\'c7\'d4\'cb\'d0\'d0\'ca\'b1\'d3\'d0\'b8\'fc\'b6\'e0\'b5\'c4\'b6\'ab\'ce\'f7\'d2\'d4\'d7\'b7\'d7\'d9
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 #if !__OBJC2__\
    Class super_class                                        OBJC2_UNAVAILABLE;\
    const char *name                                         OBJC2_UNAVAILABLE;\
    long version                                             OBJC2_UNAVAILABLE;\
    long info                                                OBJC2_UNAVAILABLE;\
    long instance_size                                       OBJC2_UNAVAILABLE;\
    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\
    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\
    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\
#endif \
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 We can see a class has a reference to it's superclass, it's name, instance variables, methods, cache and protocols it claims to adhere to. The runtime needs this information when responding to messages that message your class or it's instances.\

\f0 \'ce\'d2\'c3\'c7\'bf\'c9\'d2\'d4\'bf\'b4\'b5\'bd\'c0\'db\'d3\'d0\'d2\'bb\'b8\'f6\'d6\'b8\'cf\'f2\'cb\'fc\'b8\'a5\'c0\'d7\'b5\'c4\'d2\'fd\'d3\'c3\'a3\'ac\'cb\'fc\'b5\'c4\'c3\'fb\'d7\'d6\'a3\'ac\'ca\'b5\'c0\'fd\'b1\'e4\'c1\'bf\'a3\'ac\'ca\'b5\'c0\'fd\'b7\'bd\'b7\'a8\'a3\'ac\'bb\'ba\'b4\'e6\'ba\'cd\'cb\'fc\'cb\'f9\'d6\'a7\'b3\'d6\'b5\'c4\'d0\'ad\'d2\'e9\'a1\'a3\'d4\'cb\'d0\'d0\'ca\'b1\'d0\'e8\'d2\'aa\'d5\'e2\'d0\'a9\'d0\'c5\'cf\'a2\'b5\'b1\'c4\'e3\'b7\'a2\'cb\'cd\'cf\'fb\'cf\'a2\'b8\'f8\'c4\'e3\'b5\'c4\'c0\'e0\'bb\'f2\'d5\'df\'ca\'b5\'c0\'fd\'ca\'b1\'cf\'ec\'d3\'a6\'d5\'e2\'d0\'a9\'cf\'fb\'cf\'a2\'a1\'a3
\f2\b \

\b0 \
\pard\pardeftab720\sl440

\b \cf0 So Classes define objects and yet are objects themselves? How does this work
\b0 \
\pard\pardeftab720\sl440

\f0 \cf0 \'d3\'da\'ca\'c7\'c0\'e0\'b6\'a8\'d2\'e5\'b6\'d4\'cf\'f3\'b6\'f8\'b2\'bb\'ca\'c7\'b6\'d4\'cf\'f3\'b1\'be\'c9\'ed\'a1\'a3\'d5\'e2\'ca\'c7\'d4\'f5\'d1\'f9\'ca\'b5\'cf\'d6\'b5\'c4
\f2\b \

\b0 Yes earlier I said that in objective-c classes themselves are objects as well, and the runtime deals with this by creating Meta Classes. When you send a message like
\f4\fs24 \cf5 \cb6 [NSObject alloc]
\f2\fs26 \cf0 \cb4  you are actually sending a message to the class object, and that class object needs to be an instance of the MetaClass which itself is an instance of the root meta class. While if you say subclass from NSObject, your class points to NSObject as it's superclass. However all meta classes point to the root metaclass as their superclass. All meta classes simply have the class methods for their method list of messages that they respond to. So when you send a message to a class object like
\f4\fs24 \cf5 \cb6 [NSObject alloc]
\f2\fs26 \cf0 \cb4  then 
\f4\fs24 \cf5 \cb6 objc_msgSend()
\f2\fs26 \cf0 \cb4  actually looks through the meta class to see what it responds to then if it finds a method, operates on the Class object.\

\f0 \'d5\'fd\'cf\'f1\'ce\'d2\'d4\'e2\'cf\'ae\'ca\'b1\'ba\'f2\'cb\'b5\'b9\'fd\'b5\'c4\'d2\'bb\'d1\'f9
\f2 Objective-C
\f0 \'c0\'e0\'b1\'be\'c9\'ed\'d2\'b2\'ca\'c7\'b6\'d4\'cf\'f3\'a1\'a3\'b2\'a2\'c7\'d2\'d4\'cb\'d0\'d0\'ca\'b1\'cd\'a8\'b9\'fd\'b4\'b4\'bd\'a8\'d4\'aa\'d0\'c5\'cf\'a2\'c0\'b4\'b4\'a6\'c0\'ed\'cb\'fc\'a1\'a3\'b5\'b1\'c4\'e3\'b7\'a2\'cb\'cd\'d2\'bb\'b8\'f6\'cf\'fb\'cf\'a2\'a3\'ac\'c4\'e3\'ca\'b5\'bc\'ca\'c9\'cf\'ca\'c7\'b7\'a2\'cb\'cd\'c1\'cb\'d2\'bb\'b8\'f6\'cf\'fb\'cf\'a2\'b8\'f8\'c0\'e0\'b6\'d4\'cf\'f3\'a1\'a3\'b2\'a2\'c7\'d2\'c0\'e0\'b6\'d4\'cf\'f3\'b1\'d8\'d0\'eb\'ca\'c7\'d2\'bb\'b8\'f6\'d4\'aa\'c0\'e0\'d0\'cd\'b5\'c4\'ca\'b5\'c0\'fd\'a1\'a3\'b5\'b1\'c4\'e3\'cb\'b5\'d2\'aa\'b4\'d3
\f2 NSObject
\f0 \'bc\'cc\'b3\'d0\'b5\'c4\'ca\'b1\'ba\'f2\'a3\'ac\'c4\'e3\'b5\'c4\'c0\'e0\'d6\'b8\'d5\'eb\'d6\'b8\'cf\'f2
\f2 NSObject
\f0 \'d7\'f6\'ce\'aa\'cb\'fc\'b5\'c4\'b8\'b8\'c0\'e0\'a1\'a3\'ce\'de\'c2\'db\'d4\'f5\'d1\'f9\'a3\'ac\'cb\'f9\'d3\'d0\'d4\'aa\'c0\'e0\'d0\'cd\'b6\'bc\'d6\'b8\'cf\'f2\'b8\'f9\'d4\'aa\'c0\'e0\'d0\'cd\'d7\'f6\'ce\'aa\'cb\'fb\'c3\'c7\'b5\'c4\'b8\'a5\'c0\'d7\'a1\'a3\'cb\'f9\'d3\'d0\'b5\'c4\'d4\'aa\'c0\'e0\'d0\'cd\'ba\'dc\'bc\'f2\'b5\'a5\'b5\'c4\'d3\'d0\'d3\'c3\'c0\'e0\'b7\'bd\'b7\'a8\'cb\'fb\'c3\'c7\'c4\'dc\'b9\'bb\'cf\'ec\'d3\'a6\'b5\'c4\'cf\'fb\'cf\'a2\'b5\'c4\'c1\'d0\'b1\'ed\'a1\'a3\'cb\'f9\'d2\'d4\'a3\'ac\'b5\'b1\'c4\'e3\'b7\'a2\'cb\'cd\'d2\'bb\'b8\'f6\'d0\'a1\'ca\'b1\'b8\'f8\'d2\'bb\'b8\'f6\'c0\'e0\'b6\'d4\'cf\'f3\'b5\'c4\'ca\'b1\'ba\'f2\'a3\'ac\'ca\'b5\'bc\'ca\'c9\'cf\'bc\'ec\'b2\'e9\'c1\'cb\'d4\'aa\'c0\'e0\'d0\'cd\'c0\'b4\'c8\'b7\'b6\'a8\'cb\'fc\'ca\'b1\'ba\'f2\'c4\'dc\'b9\'bb\'cf\'ec\'d3\'a6\'a3\'ac\'b2\'a2\'c7\'d2\'c8\'e7\'b9\'fb\'bf\'c9\'d2\'d4\'d5\'d2\'b5\'bd\'d2\'bb\'b8\'f6\'b7\'bd\'b7\'a8\'a3\'ac\'d4\'da\'c0\'e0\'c9\'cf\'d6\'b4\'d0\'d0\'b8\'c3\'b7\'bd\'b7\'a8\'a1\'a3
\f2 \
\pard\pardeftab720\sl440

\b \cf0 Why we subclass from Apples Classes
\b0 \
\pard\pardeftab720\sl440

\f0 \cf0 \'ce\'aa\'ca\'b2\'c3\'b4\'ce\'d2\'c3\'c7\'b4\'d3\'c6\'bb\'b9\'fb\'b5\'c4\'c0\'e0\'d0\'cd\'bc\'cc\'b3\'d0
\f2 \
So initially when you start Cocoa development, tutorials all say to do things like subclass NSObject and start then coding something and you enjoy a lot of benefits simply by inheriting from Apples Classes. One thing you don't even realize that happens for you is setting your objects up to work with the Objective-C runtime. When we allocate an instance of one of our classes it's done like so\'85\

\f0 \'d4\'da\'c4\'e3\'d7\'ee\'bf\'aa\'ca\'bc\'bf\'aa\'b7\'a2
\f2 Cocoa
\f0 \'b3\'cc\'d0\'f2\'b5\'c4\'ca\'b1\'ba\'f2\'a3\'ac\'bd\'cc\'b3\'cc\'b6\'bc\'b3\'f6\'d2\'aa\'b4\'d3
\f2 NSobject
\f0 \'bd\'e1\'b3\'c9\'a3\'ac\'c8\'bb\'ba\'f3\'bf\'aa\'ca\'bc\'d0\'b4\'b4\'fa\'c2\'eb\'a3\'ac\'c4\'e3\'bb\'e1\'cf\'ed\'ca\'dc\'b4\'d3\'c6\'bb\'b9\'fb\'b5\'c4\'c0\'e0\'bc\'cc\'b3\'d0\'b4\'f8\'c0\'b4\'b5\'c4\'c0\'d6\'c8\'a4\'a1\'a3\'d2\'bb\'bc\'fe\'ca\'c2\'c7\'e9\'c4\'e3\'c9\'f5\'d6\'c1\'c3\'bb\'d3\'d0\'d7\'a2\'d2\'e2\'b5\'bd\'a3\'ac\'be\'cd\'ca\'c7\'b5\'bd\'b5\'d7\'b7\'a8\'c9\'ed\'c1\'cb\'ca\'b2\'c3\'b4\'b5\'b1\'c4\'e3\'d7\'e9\'d6\'af\'c4\'e3\'b5\'c4\'b6\'d4\'cf\'f3\'d4\'da
\f2 Objectiv-C
\f0 \'d4\'cb\'d0\'d0\'ca\'b1\'bb\'b7\'be\'b3\'c9\'cf\'a1\'a3\'b5\'ab\'c4\'e3\'ca\'b5\'c0\'fd\'bb\'af\'c1\'cb\'c4\'e3\'b5\'c4\'c0\'e0\'a3\'ac\'cf\'f1\'d5\'e2\'d1\'f9\'a3\'ba
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 MyObject *object = [[MyObject alloc] init];\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 the very first message that gets executed is 
\f4\fs24 \cf5 \cb6 +alloc
\f2\fs26 \cf0 \cb4 . If you {\field{\*\fldinst{HYPERLINK "http://developer.apple.com/mac/library/documentation/cocoa/reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#jumpTo_4"}}{\fldrslt \cf7 look at the documentation}} it says that "The isa instance variable of the new instance is initialized to a data structure that describes the class; memory for all other instance variables is set to 0." So by inheriting from Apples classes we not only inherit some great attributes, but we inherit the ability to easily allocate and create our objects in memory that matches a structure the runtime expects (with a isa pointer that points to our class) & is the size of our class.\

\f0 \'b5\'da\'d2\'bb\'b8\'f6\'d6\'b4\'d0\'d0\'b5\'c4\'cf\'fb\'cf\'a2\'ca\'c7
\f2\b alloc
\f0\b0 \'a1\'a3\'c8\'e7\'b9\'fb\'c4\'e3\'b2\'e9\'d4\'c4\'ce\'c4\'b5\'b5\'a3\'ac\'cb\'fc\'cb\'b5
\f2\b \'93
\f0\b0 \'d2\'bb\'b8\'f6\'d0\'c2\'ca\'b5\'c0\'fd\'b5\'c4
\f2\b ISA
\f0\b0 \'ca\'b5\'c0\'fd\'b1\'bb\'b3\'f5\'ca\'bc\'bb\'af\'b3\'c9\'c3\'e8\'ca\'f6\'d5\'e2\'b8\'f6\'c0\'e0\'b5\'c4\'d2\'bb\'b8\'f6\'ca\'fd\'be\'dd\'bd\'e1\'b9\'b9\'a3\'ac\'cb\'f9\'d3\'d0\'c6\'e4\'cb\'fb\'b5\'c4\'ca\'b5\'c0\'fd\'b5\'c4\'c3\'bb\'b4\'e6\'b1\'bb\'c9\'e8\'d6\'c3\'b3\'c9
\f2\b 0\'94
\f0\b0 \'a1\'a3\'d3\'da\'ca\'c7\'b4\'d3\'c6\'bb\'b9\'fb\'c0\'db\'bc\'cc\'b3\'d0\'ce\'d2\'c3\'c7\'b2\'bb\'d6\'b9\'bc\'cc\'b3\'d0\'c1\'cb\'d2\'bb\'d0\'a9\'ca\'f4\'d0\'d4\'a3\'ac\'b6\'f8\'c7\'d2\'ce\'d2\'c3\'c7\'bb\'b9\'bc\'cc\'b3\'d0\'c1\'cb\'bc\'f2\'b5\'a5\'b5\'c4\'c4\'da\'b4\'e6\'b7\'d6\'c5\'e4\'ba\'cd\'d4\'da\'c4\'da\'b4\'e6\'d6\'d0\'b4\'b4\'bd\'a8\'b7\'fb\'ba\'cf\'d4\'cb\'d0\'d0\'ca\'b1\'c6\'da\'cd\'fb\'b4\'f3\'d0\'a1\'b5\'c4\'ce\'d2\'c3\'c7\'b5\'c4\'b6\'d4\'cf\'f3\'a1\'a3
\f2\b \

\b0 \
\pard\pardeftab720\sl440

\b \cf0 So what's with the Class Cache? ( objc_cache *cache )
\b0 \
\pard\pardeftab720\sl440

\f0 \cf0 \'c0\'e0
\f2 Cache
\f0 \'ca\'c7\'b8\'f6\'ca\'b2\'c3\'b4\'b6\'ab\'ce\'f7\'a3\'bf
\f2 \
When the Objective-C runtime inspects an object by following it's isa pointer it can find an object that implements many methods. However you may only call a small portion of them and it makes no sense to search the classes dispatch table for all the selectors every time it does a lookup. So the class implements a cache, whenever you search through a classes dispatch table and find the corresponding selector it puts that into it's cache. So when 
\f4\fs24 \cf5 \cb6 objc_msgSend()
\f2\fs26 \cf0 \cb4  looks through a class for a selector it searches through the class cache first. This operates on the theory that if you call a message on a class once, you are likely to call that same message on it again later. So if we take this into account this means that if we have a subclass of 
\f4\fs24 \cf5 \cb6 NSObject
\f2\fs26 \cf0 \cb4  called 
\f4\fs24 \cf5 \cb6 MyObject
\f2\fs26 \cf0 \cb4  and run the following code\

\f0 \'b5\'b1
\f2 Objective-C
\f0 \'d4\'cb\'d0\'d0\'ca\'b1\'cd\'a8\'b9\'fd\'b8\'fa\'d7\'d9\'d2\'bb\'b8\'f6\'b6\'d4\'cf\'f3\'b5\'c4
\f2 ISA
\f0 \'d6\'b8\'d5\'eb\'c0\'b4\'bc\'ec\'b2\'e9\'d2\'bb\'b8\'f6\'b6\'d4\'cf\'f3\'b5\'c4\'ca\'b1\'ba\'f2\'a3\'ac\'cb\'fc\'bd\'ab\'bb\'e1\'b7\'a2\'cf\'d6\'d2\'bb\'b8\'f6\'ca\'b5\'cf\'d6\'c1\'cb\'ba\'dc\'b6\'e0\'b7\'bd\'b7\'a8\'b5\'c4\'b6\'d4\'cf\'f3\'a1\'a3\'ce\'de\'c2\'db\'d4\'f5\'d1\'f9\'a3\'ac\'c4\'e3\'d6\'bb\'bb\'e1\'b5\'f7\'d3\'c3\'cb\'fb\'c3\'c7\'ba\'dc\'c9\'d9\'b5\'c4\'d2\'bb\'b2\'bf\'b7\'d6\'b2\'a2\'c7\'d2\'cd\'ea\'c8\'ab\'c3\'bb\'d3\'d0\'d2\'e2\'d2\'e5\'c8\'a5\'bc\'ec\'b2\'e9\'c0\'e0\'b5\'c4\'b7\'bd\'b7\'a8\'d6\'b4\'d0\'d0\'b1\'ed\'c3\'bf\'b4\'ce\'bc\'ec\'b2\'e9\'b5\'c4\'ca\'b1\'ba\'f2\'a1\'a3\'d3\'da\'ca\'c7\'c0\'e0\'ca\'b5\'cf\'d6\'c1\'cb\'d2\'bb\'b8\'f6
\f2 Cache
\f0 \'a3\'ac\'b5\'b1\'c4\'e3\'b2\'e9\'d5\'d2\'c0\'e0\'b5\'c4
\f2 dispatch table
\f0 \'b2\'a2\'c7\'d2\'cf\'eb\'d5\'d2\'b5\'bd\'b6\'d4\'d3\'a6\'b5\'c4\'b7\'bd\'b7\'a8\'b5\'c4\'ca\'b1\'a3\'ac\'bd\'ab\'bb\'e1\'b0\'d1\'b7\'bd\'b7\'a8\'b7\'c5\'c8\'eb
\f2 cache
\f0 \'d6\'d0\'a1\'a3\'d3\'da\'ca\'c7\'b5\'b1
\f2 Ojbc_msgSend()
\f0 \'bc\'ec\'b2\'e9\'d2\'bb\'b8\'f6\'c0\'e0\'b2\'e9\'d5\'d2\'d2\'bb\'b8\'f6\'b7\'bd\'b7\'a8\'b5\'c4\'ca\'b1\'ba\'f2\'a3\'ac\'cb\'fc\'bb\'e1\'cf\'c8\'bc\'ec\'b2\'e9
\f2 cache
\f0 \'a1\'a3\'d5\'e2\'b8\'f6\'b2\'d9\'d7\'f7\'bb\'f9\'d3\'da\'d5\'e2\'d1\'f9\'b5\'c4\'c0\'ed\'c2\'db\'a3\'ac\'b5\'b1\'c4\'e3\'d4\'da\'d2\'bb\'b8\'f6\'c0\'e0\'c9\'cf\'d6\'b4\'d0\'d0\'d2\'bb\'b8\'f6\'b7\'bd\'b7\'a8\'d2\'bb\'b4\'ce\'d6\'ae\'ba\'f3\'a3\'ac\'c4\'e3\'bd\'ab\'bb\'e1\'d6\'b4\'d0\'d0\'cf\'e0\'cd\'ac\'b5\'c4\'b7\'bd\'b7\'a8\'d4\'da\'d6\'ae\'ba\'f3\'b5\'c4\'d2\'bb\'b6\'ce\'ca\'b1\'bc\'e4\'c4\'da\'a1\'a3\'d3\'da\'ca\'c7\'a3\'ac\'c8\'e7\'b9\'fb\'ce\'d2\'c3\'c7\'d7\'c5\'d6\'d8\'bf\'bc\'c2\'c7\'d2\'bb\'cf\'c2\'d5\'e2\'b8\'f6\'a3\'ac\'c8\'e7\'b9\'fb\'ce\'d2\'c3\'c7\'d3\'d0\'d2\'bb\'b8\'f6\'bd\'d0\'d7\'f6
\f2 MyObject
\f0 \'b5\'c4
\f2 NSObject
\f0 \'b5\'c4\'d7\'d3\'c0\'e0\'a3\'ac\'b2\'a2\'c7\'d2\'d4\'cb\'d0\'d0\'cf\'c2\'c1\'d0\'b4\'fa\'c2\'eb
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 MyObject *obj = [[MyObject alloc] init];\
 \
@implementation MyObject\
-(id)init \{\
    if(self = [super init])\{\
        [self setVarA:@\'94blah\'94];\
    \}\
    return self;\
\}\
@end\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 the following happens\

\f0 \'d5\'e2\'d0\'a9\'bd\'ab\'bb\'e1\'b7\'a2\'c9\'fa\'a3\'ac
\f2 \
(1) 
\f4\fs24 \cf5 \cb6 [MyObject alloc]
\f2\fs26 \cf0 \cb4  gets executed first. MyObject class doesn't implement alloc so we will fail to find 
\f4\fs24 \cf5 \cb6 +alloc
\f2\fs26 \cf0 \cb4  in the class and follow the superclass pointer which points to 
\f4\fs24 \cf5 \cb6 NSObject
\f2\fs26 \cf0 \cb4 \
(1) 
\f4\fs22 \cf5 \cb6 [MyObject alloc]
\f2\fs26 \cf0 \cb4  
\f0 \'bd\'ab\'bb\'e1\'b5\'da\'d2\'bb\'b8\'f6\'d6\'b4\'d0\'d0\'a1\'a3
\f2 MyObject
\f0 \'c0\'e0\'c3\'bb\'d3\'d0\'ca\'b5\'cf\'d6
\f2 alloc
\f0 \'a3\'ac\'d3\'da\'ca\'c7\'ce\'d2\'c3\'c7\'b2\'e9\'d5\'d2
\f2  
\f4\fs22 \cf5 \cb6 +alloc
\f2\fs26 \cf0 \cb4  
\f0 \'ca\'a7\'b0\'dc\'d4\'da\'d5\'e2\'b8\'f6\'c0\'e0\'d6\'d0\'a3\'ac\'c8\'bb\'ba\'f3\'ce\'d2\'c3\'c7\'b8\'fa\'d7\'d9\'d7\'c5\'cb\'fb\'b5\'c4\'b8\'b8\'c0\'e0\'d6\'b8\'d5\'eb
\f2  
\f4\fs22 \cf5 \cb6 NSObject
\f2\fs26 \cf0 \cb4 \
(2) We ask 
\f4\fs24 \cf5 \cb6 NSObject
\f2\fs26 \cf0 \cb4  if it responds to 
\f4\fs24 \cf5 \cb6 +alloc
\f2\fs26 \cf0 \cb4  and it does. 
\f4\fs24 \cf5 \cb6 +alloc
\f2\fs26 \cf0 \cb4  checks the receiver class which is 
\f4\fs24 \cf5 \cb6 MyObject
\f2\fs26 \cf0 \cb4  and allocates a block of memory the size of our class and initializes it's isa pointer to the MyObject class and we now have an instance and lastly we put 
\f4\fs24 \cf5 \cb6 +alloc in NSObject's class cache for the class object
\f2\fs26 \cf0 \cb4 \

\f0 \'ce\'d2\'c3\'c7\'b2\'e9\'d1\'af
\f2  
\f4\fs22 \cf5 \cb6 NSObject
\f2\fs26 \cf0 \cb4  
\f0 \'ca\'c7\'b7\'f1\'b6\'d4
\f2  
\f4\fs22 \cf5 \cb6 +alloc
\f2\fs26 \cf0 \cb4  
\f0 \'cf\'ec\'d3\'a6\'a3\'ac\'b2\'a2\'c7\'d2\'b5\'c4\'c8\'b7\'c8\'e7\'b4\'cb
\f2 . 
\f4\fs22 \cf5 \cb6 +alloc
\f2\fs26 \cf0 \cb4  
\f0 \'b2\'e9\'d5\'d2\'bd\'d3\'ca\'dc\'c0\'e0
\f2  
\f4\fs22 \cf5 \cb6 MyObject
\f2\fs26 \cf0 \cb4  
\f0 \'b2\'a2\'c7\'d2\'b7\'d6\'c5\'e4\'c4\'da\'b4\'e6\'a3\'ac\'bd\'ab
\f2 ISA
\f0 \'d6\'b8\'d5\'eb\'d6\'b8\'cf\'f2
\f2 MyObject
\f0 \'c0\'e0\'b2\'a2\'c7\'d2\'ce\'d2\'c3\'c7\'d3\'d0\'c1\'cb\'d2\'bb\'b8\'f6\'ca\'b5\'c0\'fd\'a3\'ac\'d7\'ee\'ba\'f3\'ce\'d2\'c3\'c7\'bd\'ab
\f2 alloc
\f0 \'b7\'c5\'c8\'eb\'d5\'e2\'b8\'f6\'c0\'e0\'b5\'c4\'bb\'ba\'b4\'e6\'d6\'d0
\f2 \
(3) Up till now we were sending a class messages but now we send an instance message which simply calls 
\f4\fs24 \cf5 \cb6 -init
\f2\fs26 \cf0 \cb4  or our designated initializer. Of course our calss responds to that message so 
\f4\fs24 \cf5 \cb6 -(id)init
\f2\fs26 \cf0 \cb4  get's put into the cache\

\f0 \'cf\'d6\'d4\'da\'ce\'d2\'c3\'c7\'d5\'fd\'d4\'da\'b7\'a2\'cb\'cd\'d2\'bb\'b8\'f6\'c0\'e0\'cf\'fb\'cf\'a2\'a3\'ac\'b5\'ab\'ca\'c7\'ce\'d2\'c3\'c7\'b7\'a2\'cb\'cd\'c1\'cb\'d2\'bb\'b8\'f6\'ca\'b5\'c0\'fd\'cf\'fb\'cf\'a2\'a3\'a8\'b1\'bb\'b3\'cb\'d7\'f8
\f2 init
\f0 \'bb\'f2\'d5\'df\'ce\'d2\'c3\'c7\'b5\'c4\'b9\'b9\'d4\'ec\'c6\'f7\'a3\'a9\'a1\'a3\'b5\'b1\'c8\'bb\'ce\'d2\'c3\'c7\'b5\'c4\'c0\'e0\'cf\'ec\'d3\'a6\'b8\'c3\'cf\'fb\'cf\'a2\'b2\'a2\'c7\'d2\'b7\'c5\'c8\'eb\'c1\'cb
\f2 cache
\f0 \'a1\'a3
\f2 \
(4) Then 
\f4\fs24 \cf5 \cb6 self = [super init]
\f2\fs26 \cf0 \cb4  gets called. Super being a magic keyword that points to the objects superclass so we go to 
\f4\fs24 \cf5 \cb6 NSObject
\f2\fs26 \cf0 \cb4  and call it's init method. This is done to insure that OOP Inheritance works correctly in that all your super classes will initialize their variables correctly and then you (being in the subclass) can initialize your variables correctly and then override the superclasses if you really need to. In the case of NSObject, nothing of huge importance goes on, but that is not always the case. Sometimes important initialization happens. Take this\'85\

\f0 \'c8\'bb\'ba\'f3
\f2  self = [super inti]
\f0 \'b1\'bb\'b5\'f7\'d3\'c3\'a1\'a3
\f2 super
\f0 \'ca\'c7\'d2\'bb\'b8\'f6\'c9\'f1\'c6\'e6\'b5\'c4\'b9\'d8\'bc\'fc\'d7\'d6\'d6\'b8\'cf\'f2\'c0\'e0\'b5\'c4\'b8\'b8\'c0\'e0\'a3\'a8
\f2 NSObject
\f0 \'a3\'a9\'a3\'ac\'b2\'a2\'c7\'d2\'b5\'f7\'d3\'c3\'b8\'b8\'c0\'e0\'b5\'c4\'b3\'f5\'ca\'bc\'bb\'af\'b7\'bd\'b7\'a8\'a1\'a3\'d5\'e2\'ca\'c7\'ce\'aa\'c1\'cb\'c8\'b7\'b1\'a3
\f2 OOP
\f0 \'bc\'cc\'b3\'d0\'b9\'a4\'d7\'f7\'d5\'fd\'b3\'a3\'a1\'a3\'d4\'da\'cb\'f9\'d3\'d0\'b5\'c4\'b8\'a5\'c0\'d7\'b3\'f5\'ca\'bc\'bb\'af\'cb\'fb\'c3\'c7\'b5\'c4\'b1\'e4\'c1\'bf\'d5\'fd\'b3\'a3\'d6\'ae\'ba\'f3\'a3\'ac\'c4\'e3\'bf\'c9\'d2\'d4\'b3\'f5\'ca\'bc\'bb\'af\'c4\'e3\'b5\'c4\'b1\'e4\'c1\'bf\'a1\'a3\'c8\'bb\'ba\'f3\'cd\'c6\'b7\'ad\'c4\'e3\'b5\'c4\'b8\'b8\'c0\'e0\'a3\'ac\'c8\'e7\'b9\'fb\'c4\'e3\'d5\'e6\'b5\'c4\'d2\'aa\'d5\'e2\'c3\'b4\'d7\'f6\'a1\'a3\'d4\'da
\f2 NSObject
\f0 \'b5\'c4\'c7\'e9\'bf\'f6\'cf\'c2\'a3\'ac\'c3\'bb\'d3\'d0\'ca\'b2\'c3\'b4\'b7\'c7\'b3\'a3\'d6\'d0\'b5\'c4\'ca\'c2\'c7\'e9\'bd\'f8\'d0\'d0\'a3\'ac\'b5\'ab\'ca\'c7\'d5\'e2\'b2\'a2\'b2\'bb\'ca\'c7\'b3\'a3\'cc\'ac\'a1\'a3\'d3\'d0\'d0\'a9\'ca\'b1\'ba\'f2\'ba\'dc\'d6\'d8\'d2\'aa\'b5\'c4\'b3\'f5\'ca\'bc\'bb\'af\'bb\'e1\'b7\'a2\'c9\'fa\'a3\'ac\'bf\'bc\'c2\'c7\'a3\'ba
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 #import < Foundation/Foundation.h>\
 \
@interface MyObject : NSObject\
\{\
 NSString *aString;\
\}\
 \
@property(retain) NSString *aString;\
 \
@end\
 \
@implementation MyObject\
 \
-(id)init\
\{\
 if (self = [super init]) \{\
  [self setAString:nil];\
 \}\
 return self;\
\}\
 \
@synthesize aString;\
 \
@end\
 \
 \
 \
int main (int argc, const char * argv[]) \{\
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];\
 \
 id obj1 = [NSMutableArray alloc];\
 id obj2 = [[NSMutableArray alloc] init];\
  \
 id obj3 = [NSArray alloc];\
 id obj4 = [[NSArray alloc] initWithObjects:@"Hello",nil];\
  \
 NSLog(@"obj1 class is %@",NSStringFromClass([obj1 class]));\
 NSLog(@"obj2 class is %@",NSStringFromClass([obj2 class]));\
  \
 NSLog(@"obj3 class is %@",NSStringFromClass([obj3 class]));\
 NSLog(@"obj4 class is %@",NSStringFromClass([obj4 class]));\
  \
 id obj5 = [MyObject alloc];\
 id obj6 = [[MyObject alloc] init];\
  \
 NSLog(@"obj5 class is %@",NSStringFromClass([obj5 class]));\
 NSLog(@"obj6 class is %@",NSStringFromClass([obj6 class]));\
  \
 [pool drain];\
    return 0;\
\}\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 Now if you were new to Cocoa and I asked you to guess as to what would be printed you'd probably say\

\f0 \'cf\'d6\'d4\'da\'c8\'e7\'b9\'fb\'c4\'e3\'b8\'d5\'bd\'d3\'b4\'a5
\f2 Cocoa
\f0 \'a3\'ac\'c8\'e7\'b9\'fb\'ce\'d2\'ce\'ca\'c4\'e3\'bd\'ab\'bb\'e1\'b4\'f2\'d3\'a1\'ca\'b2\'c3\'b4\'c4\'e3\'bb\'e1\'cb\'b5\'a1\'a3
\f2 \
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 NSMutableArray\
NSMutableArray \
NSArray\
NSArray\
MyObject\
MyObject\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 but this is what happens\
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 obj1 class is __NSPlaceholderArray\
obj2 class is NSCFArray\
obj3 class is __NSPlaceholderArray\
obj4 class is NSCFArray\
obj5 class is MyObject\
obj6 class is MyObject\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 This is because in Objective-C there is a potential for 
\f4\fs24 \cf5 \cb6 +alloc
\f2\fs26 \cf0 \cb4  to return an object of one class and then 
\f4\fs24 \cf5 \cb6 -init
\f2\fs26 \cf0 \cb4  to return an object of another class.\

\f0 \'d2\'f2\'ce\'aa\'d4\'da
\f2 Objective-C
\f0 \'d6\'d0\'b4\'e6\'d4\'da\'d5\'e2\'d1\'f9\'b5\'c4\'bf\'c9\'c4\'dc\'a3\'ac
\f2 alloc
\f0 \'b7\'b5\'bb\'d8\'d2\'bb\'b8\'f6\'c0\'e0\'d0\'cd\'a3\'ac\'b6\'f8
\f2 init
\f0 \'b7\'b5\'bb\'d8\'c1\'ed\'cd\'e2\'d2\'bb\'b8\'f6\'c0\'e0\'d0\'cd\'a1\'a3
\f2 \
\pard\pardeftab720\sl440

\b \cf0 So what happens in objc_msgSend anyway?
\b0 \
\pard\pardeftab720\sl440

\f0 \cf0 \'d4\'da
\f2 objc_msgSend
\f0 \'ca\'b1\'b7\'a2\'c9\'fa\'c1\'cb\'ca\'b2\'c3\'b4\'a3\'bf
\f2 \
There is actually a lot that happens in 
\f4\fs24 \cf5 \cb6 objc_msgSend()
\f2\fs26 \cf0 \cb4 . Lets say we have code like this\'85\

\f0 \'ca\'b5\'bc\'ca\'c9\'cf\'d4\'da
\f2 objc_msgSend
\f0 \'a3\'a8\'a3\'a9\'d6\'d0\'b7\'a2\'c9\'fa\'c1\'cb\'ba\'dc\'b6\'e0\'ca\'c2\'c7\'e9\'a1\'a3\'c8\'c3\'ce\'d2\'bf\'b4\'d2\'bb\'cf\'c2\'bc\'d9\'c9\'e8\'ce\'d2\'c3\'c7\'d3\'d0\'d5\'e2\'d1\'f9\'b5\'c4\'b4\'fa\'c2\'eb
\f2 ...\
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 [self printMessageWithString:@"Hello World!"];\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 it actually get's translated by the compiler to\'85\

\f0 \'cb\'fc\'ca\'b5\'bc\'ca\'c9\'cf\'b1\'bb\'b1\'e0\'d2\'eb\'c6\'f7\'b7\'ad\'d2\'eb\'b3\'c9\'c1\'cb
\f5\fs24 \
\pard\pardeftab720\sl440

\f4 \cf5 \cb6 objc_msgSend(self,@selector(printMessageWithString:),@"Hello World!");\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 From there we follow the target objects isa pointer to lookup and see if the object (or any of it's superclasses) respond to the selector
\f4\fs24 \cf5 \cb6 @selector(printMessageWithString:)
\f2\fs26 \cf0 \cb4 . Assuming we find the selector in the class dispatch table or it's cache we follow the function pointer and execute it. Thus
\f4\fs24 \cf5 \cb6 objc_msgSend()
\f5 \cf0 \cb4  
\f2\fs26 never returns, it begins executing and then follows a pointer to your methods and then your methods return, thus looking like
\f5\fs24  
\f4 \cf5 \cb6 objc_msgSend()
\f5 \cf0 \cb4  
\f2\fs26 returned. Bill Bumgarner went into much more detail (
\f5\fs24  {\field{\*\fldinst{HYPERLINK "http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/"}}{\fldrslt 
\f2\fs26 \cf7 Part 1}}
\f2\fs26 ,
\f5\fs24  {\field{\*\fldinst{HYPERLINK "http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-2-setting-the-stage/"}}{\fldrslt 
\f2\fs26 \cf7 Part 2}} 
\f2\fs26 &
\f5\fs24  {\field{\*\fldinst{HYPERLINK "http://www.friday.com/bbum/2009/12/18/objc_msgsend-tour-part-3-the-fast-path/"}}{\fldrslt 
\f2\fs26 \cf7 Part 3}}
\f2\fs26 ) on
\f5\fs24  
\f4 \cf5 \cb6 objc_msgSend()
\f5 \cf0 \cb4  
\f2\fs26 than I will here. But to summarize what he said and what you'd see looking at the Objective-C runtime code
\fs24 \'85 
\f0\fs26 \'b4\'d3\'d5\'e2\'c0\'ef\'ce\'d2\'c3\'c7\'b8\'fa\'d7\'d9\'c4\'bf\'b1\'ea\'b6\'d4\'cf\'f3\'b5\'c4
\f2 ISA
\f0 \'d6\'b8\'d5\'eb\'c0\'b4\'b2\'e9\'d5\'d2\'ba\'cd\'c5\'d0\'b6\'cf\'d5\'e2\'b8\'f6\'b6\'d4\'cf\'f3\'ca\'c7\'b7\'f1\'cf\'ec\'d3\'a6
\f2  @selector(printMessageWithString:)
\f0 \'a1\'a3\'bc\'d9\'c9\'e8\'ce\'d2\'c3\'c7\'d5\'d2\'b5\'bd\'c1\'cb\'d5\'e2\'b8\'f6\'d1\'a1\'d4\'f1\'c6\'f7\'d4\'da\'d5\'e2\'b8\'f6\'c0\'e0\'b5\'c4
\f2 dispatch
\f0 \'b1\'ed\'bb\'f2\'d5\'df
\f2 cache
\f0 \'d6\'d0\'a1\'a3\'ce\'d2\'c3\'c7\'d1\'ad\'d7\'c5\'ba\'af\'ca\'fd\'d6\'b8\'d5\'eb\'c8\'bb\'ba\'f3\'d6\'b4\'d0\'d0\'cb\'fc\'a1\'a3\'c8\'bb\'ba\'f3
\f2 objc_msgSend()
\f0 \'b4\'d3\'c0\'b4\'b2\'bb\'b7\'b5\'bb\'d8\'a1\'a3\'cb\'fc\'bf\'aa\'ca\'bc\'d6\'b4\'d0\'d0\'a3\'ac\'b2\'a2\'c7\'d2\'b8\'fa\'d7\'d9\'d6\'b8\'cf\'f2\'c4\'e3\'b5\'c4\'b7\'bd\'b7\'a8\'b5\'c4\'d6\'b8\'d5\'eb\'a3\'ac\'c8\'bb\'ba\'f3\'c4\'e3\'b5\'c4\'b7\'bd\'b7\'a8\'b7\'b5\'bb\'d8\'a1\'a3\'d5\'e2\'bf\'b4\'c6\'f0\'c0\'b4\'cf\'f1
\f2 objc_msgSend
\f0 \'a3\'a8\'a3\'a9\'b7\'b5\'bb\'d8\'b5\'c4\'d2\'bb\'d1\'f9\'a1\'a3
\f2 Bill Bumgarner 
\f0 \'cf\'eb\'d2\'aa\'bd\'e2\'ca\'cd\'b8\'fc\'b6\'e0\'b5\'c4\'b6\'ab\'ce\'f7\'b9\'d8\'d3\'da
\f2 objc_msgSend()
\f0 \'b1\'c8\'ce\'d2\'d4\'da\'d5\'e2\'c0\'ef\'a1\'a3\'b5\'ab\'ca\'c7\'d7\'dc\'bd\'e1\'c6\'f0\'c0\'b4\'a3\'ac\'cb\'fb\'cb\'b5\'b5\'c4\'ba\'cd\'c4\'e3\'d4\'da\'d4\'cb\'d0\'d0\'ca\'b1\'bf\'b4\'b5\'bd\'b5\'c4\'a1\'a3
\f2\fs24 \

\fs26 1. Checks for Ignored Selectors & Short Circut - Obviously if we are running under garbage collection we can ignore calls to
\f5\fs24  
\f4 \cf5 \cb6 -retain
\f2\fs26 \cf0 \cb4 ,
\f4\fs24 \cf5 \cb6 -release
\f2\fs26 \cf0 \cb4 , etc
\f5\fs24  
\f0\fs26 \'bc\'ec\'b2\'e9\'ba\'f6\'c2\'d4\'b5\'c4
\f2 Selector
\f0 \'ba\'cd
\f2 Short
\fs24  Circuit
\f0 \'a3\'ac\'ba\'dc\'c3\'f7\'cf\'d4\'b5\'b1\'ce\'d2\'c3\'c7\'d4\'cb\'d0\'d0\'d4\'da\'d3\'d0\'c0\'ac\'bb\'f8\'bb\'d8\'ca\'d5\'bb\'fa\'d6\'c6\'b5\'c4\'c7\'e9\'bf\'f6\'b5\'c4\'ca\'b1\'ba\'f2\'ce\'d2\'c3\'c7\'bd\'ab\'bb\'e1\'ba\'f6\'c2\'d4
\f2 retai
\f0 \'ba\'cd
\f2 release
\f0 \'b5\'c8\'b5\'c8
\f2\fs26 2. Check for nil target. Unlike other languages messaging nil in Objective-C is perfectly legal & there are some valid reasons you'd want to. Assuming we have a non nil target we go on
\fs24 \'85
\f0 \'bc\'ec\'b2\'e9
\f2 nil
\f0 \'c4\'bf\'b1\'ea\'a1\'a3\'b2\'bb\'cf\'eb\'c6\'e4\'cb\'fb\'d3\'ef\'d1\'d4\'a3\'ac
\f2 nil
\f0 \'d4\'da
\f2 objective-C
\f0 \'d6\'d0\'ca\'c7\'d2\'bb\'b8\'f6\'cd\'ea\'c8\'ab\'ba\'cf\'b7\'a8\'a3\'ac\'b2\'a2\'c7\'d2\'d5\'e2\'c0\'ef\'d3\'d0\'ba\'dc\'b6\'e0\'d4\'ad\'d2\'f2\'c4\'e3\'d2\'b2\'d4\'b8\'d2\'e2\'d5\'e2\'d1\'f9\'a1\'a3\'c8\'e7\'b9\'fb\'ce\'d2\'c3\'c7\'d3\'d0\'d2\'bb\'b8\'f6\'b7\'c7\'bf\'d5\'b5\'c4\'b6\'d4\'cf\'f3\'ce\'d2\'c3\'c7\'bd\'ab\'bb\'e1\'bc\'cc\'d0\'f8
\f5  
\f2\fs26 3. Then we need to find the IMP on the class, so we first search the class cache for it, if found then follow the pointer and jump to the function
\f0\fs24 \'c8\'bb\'ba\'f3\'ce\'d2\'c3\'c7\'b2\'e9\'d5\'d2
\f2 IMP
\f0 \'d4\'da\'d5\'e2\'b8\'f6\'c0\'d7\'c9\'d0\'a3\'ac\'ce\'d2\'c3\'c7\'cf\'d6\'d4\'da
\f2 cache
\f0 \'d6\'d0\'bc\'ec\'b2\'e9\'cb\'fc\'a3\'ac\'c8\'e7\'b9\'fb\'d5\'d2\'b5\'bd\'c1\'cb\'be\'cd\'d1\'ad\'d7\'c5\'d6\'b8\'d5\'eb\'cc\'f8\'d7\'aa\'b5\'bd\'d5\'e2\'b8\'f6\'ba\'af\'ca\'fd
\f5  
\f2\fs26 4. If the IMP isn't found in the cache then the class dispatch table is searched next, if it's found there follow the pointer and jump to the pointer
\f0 \'c8\'e7\'b9\'fb
\f2 IMP
\f0 \'c3\'bb\'d3\'d0\'d4\'da
\f2 cache
\f0 \'d6\'d0\'d5\'d2\'b5\'bd\'a3\'ac\'ce\'d2\'c3\'c7\'be\'cd\'bc\'ec\'b2\'e9
\f2 dispatch table
\f0 \'a1\'a3\'c8\'e7\'b9\'fb\'d5\'d2\'b5\'bd\'c1\'cb\'ce\'d2\'c3\'c7\'be\'cd\'cc\'f8\'d7\'aa\'b5\'bd\'d5\'e2\'b8\'f6\'ba\'af\'ca\'fd\'d6\'ae\'d0\'d0
\f5\fs24  
\f2\fs26 5. If the IMP isn't found in the cache or class dispatch table then we jump to the forwarding mechanism This means in the end your code is transformed by the compiler into C functions. So a method you write like say
\fs20 \'85
\f5\fs24 \

\f0\fs26 \'c8\'e7\'b9\'fb
\f2 IMP
\f0 \'c3\'bb\'d3\'d0\'d4\'da
\f2 cahce
\f0 \'ba\'cd
\f2 dispatch table
\f0 \'d6\'d0\'d5\'d2\'b5\'bd\'a3\'ac\'ce\'d2\'c3\'c7\'be\'cd\'bb\'e1\'cc\'f8\'d7\'aa\'b5\'bd\'d7\'aa\'b7\'a2\'bb\'fa\'d6\'c6\'a1\'a3\'d5\'e2\'d2\'e2\'ce\'b6\'d7\'c5\'d4\'da\'c4\'e3\'b5\'c4\'b4\'fa\'c2\'eb\'b1\'bb\'b1\'e0\'d2\'eb\'c6\'f7\'d7\'aa\'bb\'af\'b3\'c9\'c1\'cb
\f2 C
\f0 \'ba\'af\'ca\'fd\'a1\'a3
\f2 \
\
\pard\pardeftab720\sl440

\f4\fs24 \cf5 \cb6 -(int)doComputeWithNum:(int)aNum \
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 would be transformed into...
\f5\fs24 \
\pard\pardeftab720\sl440

\f4 \cf5 \cb6 int aClass_doComputeWithNum(aClass *self,SEL _cmd,int aNum) \
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 And the Objective-C Runtime calls your methods by invoking function pointers to those methods. Now I said that you cannot call those translated methods directly, however the Cocoa Framework does provide a method to get at the pointer
\fs24 \'85
\f5 \
\pard\pardeftab720\sl440

\f0 \cf0 \'b2\'a2\'c7\'d2
\f2 Objective-C
\f0 \'d4\'cb\'d0\'d0\'ca\'b1\'cd\'a8\'b9\'fd\'b5\'f7\'d3\'c3\'b6\'d4\'d3\'a6\'b5\'c4\'ba\'af\'ca\'fd\'d6\'b8\'d5\'eb\'c0\'b4\'b5\'f7\'d3\'c3\'c4\'e3\'b5\'c4\'b7\'bd\'b7\'a8\'a1\'a3\'cf\'d6\'d4\'da\'ce\'d2\'cb\'b5\'c4\'e3\'b2\'bb\'c4\'dc\'d6\'b1\'bd\'d3\'b5\'f7\'d3\'c3\'d5\'e2\'d0\'a9\'b7\'ad\'d2\'eb\'ba\'f3\'b5\'c4\'b7\'bd\'b7\'a8\'a3\'ac\'cb\'e4\'c8\'bb
\f2 cocoa framework
\f0 \'cc\'e1\'b9\'a9\'c1\'cb\'b7\'bd\'b7\'a8\'c0\'b4\'bb\'f1\'c8\'a1\'d5\'e2\'d0\'a9\'d6\'b8\'d5\'eb\'a1\'a3
\f2 \
\pard\pardeftab720\sl440

\f4 \cf5 \cb6 //declare C function pointer\
int (computeNum *)(id,SEL,int);\
 \
//methodForSelector is COCOA & not ObjC Runtime\
//gets the same function pointer objc_msgSend gets\
computeNum = (int (*)(id,SEL,int))[target methodForSelector:@selector(doComputeWithNum:)];\
 \
//execute the C function pointer returned by the runtime\
computeNum(obj,@selector(doComputeWithNum:),aNum); \
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 In this way you can get direct access to the function and directly invoke it at runtime and even use this to circumvent the dynamism of the runtime if you absolutely need to make sure that a specific method is executed. This is the same way the Objective-C Runtime invokes your method, but using
\f5\fs24  
\f4 \cf5 \cb6 objc_msgSend()
\f2\fs26 \cf0 \cb4 .
\f5\fs24 \
\pard\pardeftab720

\f6 \cf0 \'cd\'a8\'b9\'fd\'d5\'e2\'d6\'d6\'b7\'bd\'b7\'a8\'c4\'e3\'bf\'c9\'d2\'d4\'d6\'b1\'bd\'d3\'d5\'d2\'b5\'bd\'ba\'af\'ca\'fd\'c8\'eb\'bf\'da\'b2\'a2\'c7\'d2\'d4\'da\'d4\'cb\'d0\'d0\'ca\'b1\'b5\'f7\'d3\'c3\'cb\'fc\'a1\'a3\'c9\'f5\'d6\'c1\'ca\'b9\'d3\'c3\'cb\'fc\'b8\'c4\'b1\'e4\'d4\'cb\'d0\'d0\'ca\'b1\'a3\'ac\'b5\'b1\'c4\'e3\'d5\'e6\'b5\'c4\'cf\'eb\'d5\'e2\'c3\'b4\'d7\'f6\'a3\'ac\'b2\'a2\'c7\'d2\'d6\'aa\'b5\'c0\'ca\'b2\'c3\'b4\'b7\'bd\'b7\'a8\'b1\'bb\'d6\'b4\'d0\'d0\'b5\'c4\'ca\'b1\'ba\'f2\'a1\'a3\'d5\'e2\'ca\'c7\'cd\'ac\'d1\'f9\'b5\'c4\'b7\'bd\'b7\'a8\'c0\'b4\'d6\'ae\'d0\'d0\'c4\'e3\'b5\'c4\'b7\'bd\'b7\'a8\'a3\'ac\'b5\'ab\'ca\'c7\'d3\'a6\'b8\'c3\'ca\'b9\'d3\'c3
\f5 objc_msgSend()
\f6 \'a3\'bb
\f5 \
\
\pard\pardeftab720\sl440

\f2\b\fs26 \cf0 Objective-C Message Forwarding
\f5\b0\fs24 \
\pard\pardeftab720\sl440

\f2 \cf0 Objective-C
\f0 \'cf\'fb\'cf\'a2\'d7\'aa\'b7\'a2
\f2 \
\pard\pardeftab720\sl440

\fs26 \cf0 In Objective-C it's very legal (and may even be an intentional design decision) to send messages to objects to which they don't know how to respond to. One reason Apple gives for this in their docs is to simulate multiple inheritance which Objective-C doesn't natively support, or you may just want to abstract your design and hide another object/class behind the scenes that deals with the message. This is one thing that the runtime is very necessary for. It works like so
\f5\fs24 \
\pard\pardeftab720\sl440

\f0 \cf0 \'d4\'da
\f2 Objective-c
\f0 \'d6\'d0\'b7\'a2\'cb\'cd\'d2\'bb\'b8\'f6\'cf\'fb\'cf\'a2\'b8\'f8\'d2\'bb\'b8\'f6\'c4\'e3\'b2\'bb\'d6\'aa\'b5\'c0\'cb\'fc\'bb\'e1\'d4\'f5\'c3\'b4\'cf\'ec\'d3\'a6\'b5\'c4\'b6\'d4\'cf\'f3\'ca\'c7\'cd\'ea\'c8\'ab\'ba\'cf\'b7\'a8\'b5\'c4\'a3\'a8\'c9\'f5\'d6\'c1\'d3\'d0\'d0\'a9\'ca\'c7\'d3\'d0\'ca\'c7\'d2\'bb\'d6\'d6\'c9\'e8\'bc\'c6\'c4\'a3\'ca\'bd\'a3\'a9\'a1\'a3\'c6\'bb\'b9\'fb\'d4\'da\'cb\'fb\'c3\'c7\'b5\'c4\'ce\'c4\'b5\'b5\'d6\'d0\'b8\'f8\'b3\'f6\'b5\'c4\'d2\'bb\'b8\'f6\'d4\'ad\'d2\'f2\'ca\'c7\'c0\'b4\'c4\'a3\'c4\'e2\'c3\'bb\'d3\'d0\'cc\'e1\'b9\'a9\'b5\'c4\'b6\'e0\'d6\'d8\'bc\'cc\'b3\'d0\'a1\'a3\'bb\'f2\'d5\'df\'c4\'e3\'cf\'eb\'be\'f8\'b6\'d4\'bb\'af\'c4\'e3\'b5\'c4\'c9\'e8\'bc\'c6\'a3\'ac\'b2\'a2\'c7\'d2\'d2\'fe\'b2\'d8\'cf\'fb\'cf\'a2\'ca\'b5\'cf\'d6\'a1\'a3\'d5\'e2\'ca\'c7\'d2\'bb\'bc\'fe\'d4\'cb\'d0\'d0\'ca\'b1\'b7\'c7\'b3\'a3\'d0\'e8\'d2\'aa\'b5\'c4\'ca\'c2\'c7\'e9\'a1\'a3\'cb\'fc\'d5\'e2\'d1\'f9\'b9\'a4\'d7\'f7
\f2 \
\pard\pardeftab720\sl440

\fs26 \cf0 1. The Runtime searches through the class cache and class dispatch table of your class and all the super classes, but fails to to find the specified method
\f5\fs24 \

\f0\fs26 \'d4\'cb\'d0\'d0\'ca\'b1\'bc\'ec\'b2\'e9\'c0\'db\'bb\'ba\'b4\'e6\'ba\'cd\'c0\'db\'b5\'c4
\f2 dipatch
\f0 \'b1\'ed\'bb\'b9\'d3\'d0\'cb\'fb\'b5\'c4\'b8\'a5\'c0\'d7\'b5\'c4\'a3\'ac\'b5\'ab\'ca\'c7\'c3\'bb\'d3\'d0\'d5\'d2\'b5\'bd\'cc\'d8\'b6\'a8\'b7\'bd\'b7\'a8
\f5\fs24 \

\f2\fs26 2. The Objective-C Runtime will call
\f5\fs24  
\f4 \cf5 \cb6 + (BOOL) resolveInstanceMethod:(SEL)aSEL
\f5 \cf0 \cb4  
\f2\fs26 on your class. This gives you a chance to provide a method implementation and tell the runtime that you've resolved this method and if it should begin to do it's search it'll find the method now. You could accomplish this like so... define a function
\fs24 \'85
\f5 \
\pard\pardeftab720\sl440

\f0 \cf0 \'d4\'cb\'d0\'d0\'ca\'b1\'bd\'ab\'bb\'e1\'b5\'f7\'d3\'c3\'d4\'da\'c4\'e3\'b5\'c4\'c0\'e0\'c9\'cf\'b5\'f7\'d3\'c3
\f2  + (BOOL) resolveInstanceMethod:(SEL)aSEL 
\f0 \'a1\'a3\'d5\'e2\'b8\'f8\'c1\'cb\'c4\'e3\'d2\'bb\'b8\'f6\'bb\'fa\'bb\'e1\'c8\'a5\'cc\'e1\'b9\'a9\'d2\'bb\'b8\'f6\'b7\'bd\'b7\'a8\'ca\'b5\'cf\'d6\'b2\'a2\'c7\'d2\'b8\'e6\'cb\'df\'d4\'cb\'d0\'d0\'ca\'b1\'c4\'e3\'c8\'e7\'ba\'ce\'bd\'e2\'be\'f6\'d5\'e2\'b8\'f6\'b7\'bd\'a3\'ac\'b2\'a2\'c7\'d2\'c8\'e7\'b9\'fb\'cb\'fc\'bf\'aa\'ca\'bc\'bc\'ec\'b2\'e9\'bd\'ab\'bb\'e1\'b5\'c3\'b5\'bd\'d5\'e2\'b8\'f6\'b7\'bd\'b7\'a8\'a1\'a3\'c4\'e3\'b1\'d8\'d0\'eb\'d5\'e2\'d1\'f9\'d7\'f6\'a3\'ba
\f2 \
\pard\pardeftab720\sl440

\f4 \cf5 \cb6 void fooMethod(id obj, SEL _cmd)\
\{\
 NSLog(@"Doing Foo");\
\}\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 you could then resolve it like so using
\f5\fs24  
\f4 \cf5 \cb6 class_addMethod()
\f2\fs26 \cf0 \cb4 ...
\f5\fs24 \
\pard\pardeftab720\sl440

\f4 \cf5 \cb6 +(BOOL)resolveInstanceMethod:(SEL)aSEL\
\{\
    if(aSEL == @selector(doFoo:))\{\
        class_addMethod([self class],aSEL,(IMP)fooMethod,"v@:");\
        return YES;\
    \}\
    return [super resolveInstanceMethod];\
\}\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 The "v@:" in the last part of
\f5\fs24  
\f4 \cf5 \cb6 class_addMethod()
\f5 \cf0 \cb4  
\f2\fs26 is what the method is returning and it's arguments. You can see what you can put there in the
\f5\fs24  {\field{\*\fldinst{HYPERLINK "http://developer.apple.com/mac/library/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1"}}{\fldrslt 
\f2\fs26 \cf7 Type Encodings}} 
\f2\fs26 section of the Runtime Guide.
\f5\fs24 \
\pard\pardeftab720\sl440

\f0 \cf0 \'d4\'da\'ba\'af\'ca\'fd\'d7\'ee\'ba\'f3\'b5\'c4
\f2 \'93v@
\f0 \'a3\'ba
\f2 \'94
\f0 \'ca\'c7\'d5\'e2\'b8\'f6\'ba\'af\'ca\'fd\'b7\'bd\'b7\'a8\'b5\'c4\'b7\'b5\'bb\'d8\'d6\'b5\'ba\'cd\'b2\'ce\'ca\'fd\'c1\'d0\'b1\'ed\'a1\'a3\'c4\'e3\'bf\'c9\'d2\'d4\'b2\'e9\'bf\'b4
\f2 Type Encodings
\f0 \'d5\'c2\'bd\'da\'bf\'b4\'bf\'b4\'c4\'e3\'c4\'dc\'b9\'bb\'d4\'da\'d5\'e2\'c0\'ef\'b7\'c5\'d0\'a9\'ca\'b2\'c3\'b4\'a1\'a3
\f2 \
\pard\pardeftab720\sl440

\fs26 \cf0 3. The Runtime then calls
\f5\fs24  
\f4 \cf5 \cb6 - (id)forwardingTargetForSelector:(SEL)aSelector
\f2\fs26 \cf0 \cb4 . What this does is give you a chance (since we couldn't resolve the method (see #2 above)) to point the Objective-C runtime at another object which should respond to the message, also this is better to do before the more expensive process of invoking
\f5\fs24  
\f4 \cf5 \cb6 - (void)forwardInvocation:(NSInvocation *)anInvocation
\f5 \cf0 \cb4  
\f2\fs26 takes over. You could implement it like so
\f5\fs24 \
\pard\pardeftab720\sl440

\f0 \cf0 \'d4\'cb\'d0\'d0\'ca\'b1\'c8\'bb\'ba\'f3\'b5\'f7\'d3\'c3\'b7\'bd\'b7\'a8
\f2  - (id)forwardingTargetForSelector:(SEL)aSelector
\f0 \'a1\'a3\'d5\'e2\'d1\'f9\'d7\'f6\'b8\'f8\'c1\'cb\'c4\'e3\'d2\'bb\'b8\'f6\'bb\'fa\'bb\'e1\'d6\'d8\'b6\'a8\'cf\'f2\'d4\'cb\'d0\'d0\'ca\'b1\'b5\'bd\'c1\'ed\'cd\'e2\'d2\'bb\'b8\'f6\'bf\'c9\'d2\'d4\'cf\'ec\'d3\'a6\'b8\'c3\'cf\'fb\'cf\'a2\'b5\'c4\'b6\'d4\'cf\'f3\'a1\'a3\'d5\'e2\'b1\'c8\'d6\'ae\'d0\'d0\'bb\'a8\'b7\'d1\'b8\'fc\'b6\'e0\'b5\'c4\'d2\'aa\'ba\'c3\'a1\'a3\'c4\'e3\'bf\'c9\'d2\'d4\'d5\'e2\'c3\'b4\'d7\'f6
\f2 \
\pard\pardeftab720\sl440

\f4 \cf5 \cb6 - (id)forwardingTargetForSelector:(SEL)aSelector\
\{\
    if(aSelector == @selector(mysteriousMethod:))\{\
        return alternateObject;\
    \}\
    return [super forwardingTargetForSelector:aSelector];\
\}\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 Obviously you don't want to ever return self from this method or it could result in an infinite loop.
\f5\fs24 \

\f0\fs26 \'ba\'dc\'c3\'f7\'cf\'d4\'c4\'e3\'b2\'bb\'bb\'e1\'cf\'eb\'d4\'da\'d5\'e2\'b8\'f6\'b7\'bd\'b7\'a8\'d6\'d0\'b7\'b5\'bb\'d8
\f2 self
\f0 \'a3\'ac\'d5\'e2\'bb\'d8\'b5\'bc\'d6\'c2\'d2\'bb\'b8\'f6\'cb\'c0\'d1\'ad\'bb\'b7\'a1\'a3
\f5\fs24 \

\f2\fs26 4. The Runtime then tries one last time to get a message sent to it's intended target and calls
\f5\fs24  
\f4 \cf5 \cb6 - (void)forwardInvocation:(NSInvocation *)anInvocation
\f2\fs26 \cf0 \cb4 . If you've never seen
\f5\fs24  {\field{\*\fldinst{HYPERLINK "http://developer.apple.com/mac/library/documentation/cocoa/Reference/Foundation/Classes/NSInvocation_Class/Reference/Reference.html"}}{\fldrslt 
\f4 \cf7 \cb6 NSInvocation}}
\f2\fs26 , it's essentially an Objective-C Message in object form. Once you have an NSInvocation you essentially can change anything about the message including it's target, selector & arguments. So you could do
\fs24 \'85
\f5 \
\pard\pardeftab720\sl440

\f0 \cf0 \'d4\'cb\'d0\'d0\'ca\'b1\'bd\'ab\'bb\'e1\'d6\'c1\'c9\'d9\'b3\'a2\'ca\'d4\'d2\'bb\'b4\'ce\'bd\'ab\'cf\'fb\'cf\'a2\'b7\'a2\'cb\'cd\'b5\'bd\'d5\'e2\'b8\'f6\'d6\'d8\'b6\'a8\'cf\'f2\'b5\'c4\'c4\'bf\'b1\'ea\'c9\'cf\'a1\'a3\'c8\'e7\'b9\'fb\'c4\'e3\'b4\'d3\'c0\'b4\'c3\'bb\'d3\'d0\'bc\'fb\'b5\'bd\'b4\'ed
\f2 NSInvocation
\f0 \'a3\'ac\'d5\'e2\'ca\'c7\'d2\'bb\'b8\'f6\'ba\'dc\'d6\'d8\'d2\'aa\'b5\'c4
\f2 Objective-C
\f0 \'b6\'d4\'cf\'f3\'d0\'ce\'ca\'bd\'b5\'c4\'cf\'fb\'cf\'a2\'a1\'a3\'d2\'bb\'b5\'a9\'c4\'e3\'d3\'d0\'c1\'cb\'d2\'bb\'b8\'f6
\f2 NSINvocation
\f0 \'c4\'e3\'bf\'c9\'d2\'d4\'b8\'c4\'b1\'e4\'c8\'ce\'ba\'ce\'b6\'ab\'ce\'f7\'b0\'fc\'c0\'a8\'cb\'fb\'b5\'c4\'c4\'bf\'b1\'ea\'a3\'ac\'b7\'bd\'b7\'a8\'a3\'ac\'b2\'ce\'ca\'fd\'a1\'a3\'c8\'ce\'ba\'ce\'c4\'e3\'bf\'c9\'d2\'d4\'d7\'f6\'b5\'c4\'a1\'a3\'a1\'a3\'a1\'a3\'a1\'a3
\f2 \
\pard\pardeftab720\sl440

\f4 \cf5 \cb6 -(void)forwardInvocation:(NSInvocation *)invocation\
\{\
    SEL invSEL = invocation.selector;\
 \
    if([altObject respondsToSelector:invSEL]) \{\
        [invocation invokeWithTarget:altObject];\
    \} else \{\
        [self doesNotRecognizeSelector:invSEL];\
    \}\
\}\
\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 by default if you inherit from NSObject it's
\f5\fs24  
\f4 \cf5 \cb6 - (void)forwardInvocation:(NSInvocation *)anInvocation
\f5 \cf0 \cb4  
\f2\fs26 implementation simply calls
\f5\fs24  
\f4 \cf5 \cb6 -doesNotRecognizeSelector:
\f2\fs26 \cf0 \cb4 which you could override if you wanted to for one last chance to do something about it.
\f5\fs24 \
\pard\pardeftab720

\f6 \cf0 \'c4\'ac\'c8\'cf\'c7\'e9\'bf\'f6\'cf\'c2\'bc\'cc\'b3\'d0
\f5 NSobject
\f6 \'b5\'c4\'b7\'bd\'b7\'a8\'ca\'b5\'cf\'d6\'a3\'ac\'d6\'bb\'ca\'c7\'bc\'f2\'b5\'a5\'b5\'c4\'b5\'f7\'d3\'c3
\f5  -doesNotRecognizeSelector: 
\f6 \'a1\'a3\'c4\'e3\'bf\'c9\'d2\'d4\'d6\'d8\'d4\'d8\'d5\'e2\'b8\'f6\'b7\'bd\'b7\'a8\'a3\'ac\'c8\'e7\'b9\'fb\'c4\'e3\'cf\'eb\'bb\'f1\'b5\'c3\'d2\'bb\'b4\'ce\'bb\'fa\'bb\'e1\'d7\'f6\'b5\'e3\'ca\'b2\'c3\'b4\'a1\'a3
\f5 \
\pard\pardeftab720\sl440

\f2\b\fs26 \cf0 Non Fragile ivars (Modern Runtime)
\f5\b0\fs24 \
\pard\pardeftab720\sl440

\f0 \cf0 \'c3\'bb\'d3\'d0\'d2\'d7\'cb\'f0\'b5\'c4\'ca\'b5\'c0\'fd
\f2 \
\pard\pardeftab720\sl440

\fs26 \cf0 One of the things we recently gained in the modern runtime is the concept of Non Fragile ivars. When compiling your classes a ivar layout is made by the compiler that shows where to access your ivars in your classes, this is the low level detail of getting a pointer to your object, seeing where the ivar is offset in relation to the beginning of the bytes the object points at, and reading in the amount of bytes that is the size of the type of variable you are reading in. So your ivar layout may look like this, with the number in the left column being the byte offset.
\f5\fs24 \
\pard\pardeftab720

\f6 \cf0 \'d2\'bb\'b8\'f6\'ce\'d2\'c3\'c7\'d7\'ee\'bd\'fc\'b4\'d3\'cf\'d6\'b4\'fa\'d4\'cb\'d0\'d0\'ca\'b1\'d6\'d0\'bb\'aa
\f5 uode
\f6 \'b5\'c4\'ba\'c3\'b4\'a6\'c3\'bb\'d3\'d0\'d2\'d7\'cb\'e9\'b5\'c4
\f5 Ivars
\f6 \'b5\'c4\'b8\'c5\'c4\'ee\'a1\'a3\'b5\'b1\'b1\'e0\'d2\'eb\'c4\'e3\'b5\'c4\'c0\'e0\'ca\'b1\'a3\'ac\'d2\'bb\'b8\'f6
\f5 ivar
\f6 \'bd\'ab\'bb\'e1\'b1\'bb\'b1\'e0\'d2\'eb\'c6\'f7\'d6\'c6\'d4\'ec\'d2\'c0\'c0\'b5\'cf\'d4\'ca\'be\'b4\'d3\'c4\'c4\'c0\'ef\'c0\'b4\'bd\'f8\'c8\'eb\'c4\'e3\'c0\'e0\'b5\'c4\'b5\'c4
\f5 ivars
\f6 \'a1\'a3\'bf\'b4\'d2\'bb\'cf\'c2\'cf\'e0\'b6\'d4\'d3\'da\'c0\'e0\'bf\'aa\'ca\'bc\'b4\'a6\'b5\'c4\'c6\'ab\'d2\'c6\'c1\'bf\'a3\'ac\'c8\'bb\'ba\'f3\'d5\'e2\'b8\'f6
\f5 bytes
\f6 \'ca\'fd\'c1\'bf\'be\'cd\'ca\'c7\'c4\'e3\'b5\'c4\'b1\'e4\'c1\'bf\'b5\'c4\'b4\'f3\'d0\'a1\'a1\'a3\'d3\'da\'ca\'c7\'c4\'e3\'b5\'c4
\f5 ivar
\f6 \'be\'cd\'cf\'eb\'d5\'e2\'d1\'f9
\f5 \
\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \'a0\'a0\

\f3\fs24 
\f2\fs26 \
\pard\pardeftab720

\f5\fs24 \cf0 \
\
\
\
\
\
\
\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 Here we have the ivar layout for NSObject and then we subclass NSObject to extend it and add on our own ivars. This works fine until Apple ships a update or all new Mac OS X 10.x release and this happens
\f5\fs24 \
\pard\pardeftab720\sl440

\f0 \cf0 \'d5\'e2\'c0\'ef\'ce\'d2\'c3\'c7\'d3\'d0\'d2\'bb\'b8\'f6
\f2 NSObject
\f0 \'b5\'c4
\f2 ivar
\f0 \'a3\'ac\'c8\'bb\'ba\'f3\'ce\'d2\'c3\'c7\'bc\'cc\'b3\'d0
\f2 NSObject
\f0 \'b2\'a2\'c7\'d2\'cc\'ed\'bc\'d3\'ce\'d2\'c3\'c7\'d7\'d4\'bc\'ba\'b5\'c4
\f2 ivar
\f0 \'a1\'a3\'d5\'e2\'b8\'f6\'d4\'da
\f2 MAC OS X 10.x
\f0 \'c9\'cf\'b9\'a4\'d7\'f7\'c1\'bc\'ba\'c3\'a1\'a3
\f2 \
\pard\pardeftab720

\f5 \cf0 \
\pard\pardeftab720\sl440

\f3 \cf0 
\f2\fs26 \
\pard\pardeftab720

\f5\fs24 \cf0 \
\
\
\
\
\
\
\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 Your custom objects get wiped out because we have an overlapping superclass. The only alternative that could prevent this is if Apple sticked with the layout it had before, but if they did that then their Frameworks could never advance because their ivar layouts were frozen in stone. Under fragile ivars you have to recompile your classes that inherit from Apples classes to restore compatibility. So what Happens under non fragile ivars?
\f5\fs24 \
\pard\pardeftab720\sl440

\f0 \cf0 \'c4\'e3\'d7\'d4\'b6\'a8\'d2\'e5\'b5\'c4\'b6\'d4\'cf\'f3\'b1\'bb\'b2\'c1\'b3\'fd\'b5\'f4\'c1\'cb\'a3\'ac\'d2\'f2\'ce\'aa\'ce\'d2\'c3\'c7\'d3\'d0\'d2\'bb\'b8\'f6\'b8\'b8\'c0\'e0\'a1\'a3\'d2\'bb\'b8\'f6\'bf\'c9\'d1\'a1\'b5\'c4\'b7\'bd\'b7\'a8\'c0\'b4\'d7\'e8\'d6\'b9\'d5\'e2\'b8\'f6\'b7\'a2\'c9\'fa\'b5\'c4\'b7\'bd\'ca\'bd\'ca\'c7\'c8\'e7\'b9\'fb\'c6\'bb\'b9\'fb\'b1\'a3\'b3\'d6\'ba\'cd\'d4\'ad\'cf\'c8\'b5\'c4
\f2 layout
\f0 \'b5\'c4\'c1\'aa\'cf\'b5\'a3\'ac\'b5\'ab\'ca\'c7\'c8\'e7\'b9\'fb\'cb\'fb\'c3\'c7\'d5\'e2\'d1\'f9\'d7\'f6\'b5\'c4\'bb\'b0\'cb\'fb\'c3\'c7\'b5\'c4
\f2 framewors
\f0 \'bd\'ab\'bb\'e1\'d3\'c0\'d4\'b6\'b1\'bb\'b6\'b3\'bd\'e1\'a1\'a3\'d4\'da\'d2\'d7\'cb\'f0\'b5\'c4
\f2 ivar
\f0 \'c9\'cf\'c4\'e3\'b1\'d8\'d0\'eb\'d6\'d8\'d0\'c2\'b1\'e0\'d2\'eb\'c4\'e3\'b5\'c4\'c0\'e0\'c0\'b4\'b4\'d3\'c6\'bb\'b9\'fb\'b5\'c4\'c0\'db\'bc\'cc\'b3\'d0\'d2\'d4\'bc\'e6\'c8\'dd\'a1\'a3\'cb\'f9\'d2\'d4\'b7\'a2\'c9\'fa\'c1\'cb\'ca\'b2\'c3\'b4\'a3\'bf
\f2 \
\pard\pardeftab720

\f5 \cf0 \
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \'a0\'a0\

\f3\fs24 
\f2\fs26 \
\pard\pardeftab720

\f5\fs24 \cf0 \
\
\
\
\
\
\
\
\
\
\pard\pardeftab720

\f2 \cf0 \
\pard\pardeftab720\sl440

\fs26 \cf0 Under Non Fragile ivars the compiler generates the same ivar layout as under fragile ivars. However when the runtime detects an overlapping superclass it adjusts the offsets to your additions to the class, thus your additions in a subclass are preserved.
\f5\fs24 \
\pard\pardeftab720

\f6 \cf0 \'d4\'da
\f5 Non fragile ivars
\f6 \'cf\'c2\'b1\'e0\'d2\'eb\'c6\'f7\'b2\'fa\'c9\'fa\'c1\'cb\'cf\'e0\'cd\'ac\'b5\'c4
\f5 ivar 
\f6 \'d3\'eb
\f5 fragile ivars
\f6 \'cf\'e0\'b1\'c8\'a1\'a3\'ce\'de\'c2\'db\'d4\'f5\'d1\'f9\'a3\'ac\'c8\'e7\'b9\'fb\'d4\'cb\'d0\'d0\'ca\'b1\'bc\'ec\'b2\'e2\'b5\'bd\'d2\'bb\'b8\'f6\'b8\'b8\'c0\'e0\'ca\'ca\'ba\'cf\'c4\'e3\'b5\'c4\'c0\'e0\'a3\'ac\'c4\'c7\'c3\'b4\'c4\'e3\'cc\'ed\'bc\'d3\'b5\'c4\'b6\'ab\'ce\'f7\'bd\'ab\'bb\'e1\'b1\'bb\'b1\'a3\'c1\'f4\'a1\'a3
\f5 \
\pard\pardeftab720\sl440

\f2\b\fs26 \cf0 Objective-C Associated Objects
\f5\b0\fs24 \
\pard\pardeftab720\sl440

\f2 \cf0 Objective-C 
\f0 \'c1\'aa\'ba\'cf\'b6\'d4\'cf\'f3
\f2 \
\pard\pardeftab720\sl440

\fs26 \cf0 One thing recently introduced in Mac OS X 10.6 Snow Leopard was called Associated References. Objective-C has no support for dynamically adding on variables to objects unlike some other languages that have native support for this. So up until now you would have had to go to great lengths to build the infrastructure to pretend that you are adding a variable onto a class. Now in Mac OS X 10.6, the Objective-C Runtime has native support for this. If we wanted to add a variable to every class that already exists like say NSView we could do so like this
\fs24 \'85
\f5 \
\pard\pardeftab720\sl440

\f0 \cf0 \'d2\'bb\'b8\'f6\'d7\'ee\'bd\'fc\'b1\'bb\'cc\'ed\'bc\'d3\'bd\'f8
\f2  Mac OS X 10.6 Snow Leopard 
\f0 \'b5\'c4\'b6\'ab\'ce\'f7\'ca\'c7\'c1\'aa\'ba\'cf\'d2\'fd\'d3\'c3\'a1\'a3
\f2 Objective-c
\f0 \'b2\'bb\'d6\'a7\'b3\'d6\'b6\'af\'cc\'ac\'cc\'ed\'bc\'d3\'b3\'c9\'d4\'b1\'b1\'e4\'c1\'bf\'a3\'ac\'b2\'bb\'cf\'f1\'c6\'e4\'cb\'fb\'d2\'bb\'d0\'a9\'d4\'ad\'c9\'fa\'d6\'a7\'b3\'d6\'d5\'e2\'b8\'f6\'b5\'c4\'d3\'ef\'d1\'d4\'a1\'a3\'cb\'f9\'d2\'d4\'d4\'da\'b4\'ce\'d6\'ae\'c7\'b0\'c4\'e3\'b1\'d8\'d0\'eb\'b9\'b9\'bc\'fe\'d2\'bb\'b8\'f6\'b7\'c7\'b3\'a3\'b4\'f3\'b5\'c4\'ca\'fd\'be\'dd\'bd\'e1\'b9\'b9\'c0\'b4\'bc\'d9\'d7\'b0\'c4\'e3\'d5\'fd\'d4\'da\'b8\'f6\'cc\'e5\'d2\'bb\'b8\'f6\'c0\'e0\'cc\'ed\'bc\'d3\'d2\'bb\'b8\'f6\'b1\'e4\'c1\'bf\'a1\'a3\'cf\'d6\'d4\'da\'d4\'da
\f2  Mac OS X 10.6 Snow Leopard 
\f0 \'d4\'cb\'d0\'d0\'ca\'b1\'d4\'ad\'c9\'fa\'d6\'a7\'b3\'d6\'d5\'e2\'b8\'f6\'a1\'a3\'c8\'e7\'b9\'fb\'ce\'d2\'c3\'c7\'cf\'eb\'d2\'aa\'cc\'ed\'bc\'d3\'d2\'bb\'b8\'f6\'b1\'e4\'c1\'bf\'b8\'f8\'c3\'bf\'d2\'bb\'b8\'f6\'d2\'d1\'be\'ad\'b4\'e6\'d4\'da\'b5\'c4\'c0\'e0\'a3\'ac\'b1\'c8\'c8\'e7
\f2 NSView
\f0 \'a3\'ac\'ce\'d2\'c3\'c7\'bf\'c9\'d2\'d4\'d5\'e2\'c3\'b4\'d7\'f6
\f2 \
\pard\pardeftab720\sl440

\f4 \cf5 \cb6 #import < Cocoa/Cocoa.h> //Cocoa\
#include < objc/runtime.h> //objc runtime api\'92s\
 \
@interface NSView (CustomAdditions)\
@property(retain) NSImage *customImage;\
@end\
 \
@implementation NSView (CustomAdditions)\
 \
static char img_key; //has a unique address (identifier)\
 \
-(NSImage *)customImage\
\{\
    return objc_getAssociatedObject(self,&img_key);\
\}\
 \
-(void)setCustomImage:(NSImage *)image\
\{\
    objc_setAssociatedObject(self,&img_key,image,\
                             OBJC_ASSOCIATION_RETAIN);\
\}\
 \
@end\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 you can see in runtime.h the options for how to store the values passed to
\f5\fs24  
\f4 \cf5 \cb6 objc_setAssociatedObject()
\f2\fs26 \cf0 \cb4 .
\f5\fs24 \
\pard\pardeftab720\sl440

\f4 \cf5 \cb6 /* Associated Object support. */\
 \
/* objc_setAssociatedObject() options */\
enum \{\
    OBJC_ASSOCIATION_ASSIGN = 0,\
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,\
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,\
    OBJC_ASSOCIATION_RETAIN = 01401,\
    OBJC_ASSOCIATION_COPY = 01403\
\}; \
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 These match up with the options you can pass in the
\f5\fs24  
\f4 \cf5 \cb6 @property
\f5 \cf0 \cb4  
\f2\fs26 syntax.
\f5\fs24 \
\pard\pardeftab720
\cf0 \
\pard\pardeftab720\sl440

\f2\b\fs26 \cf0 Hybrid vTable Dispatch
\f5\b0\fs24 \
\pard\pardeftab720\sl440

\f2\fs26 \cf0 If you look through the modern runtime code you'll come across this (in
\f5\fs24  {\field{\*\fldinst{HYPERLINK "http://opensource.apple.com/source/objc4/objc4-437/runtime/objc-runtime-new.m"}}{\fldrslt 
\f2\fs26 \cf7 objc-runtime-new.m}}
\f2\fs26 )...
\f5\fs24 \
\pard\pardeftab720\sl440

\f4 \cf5 \cb6 /***********************************************************************\
* vtable dispatch\
* \
* Every class gets a vtable pointer. The vtable is an array of IMPs.\
* The selectors represented in the vtable are the same for all classes\
*   (i.e. no class has a bigger or smaller vtable).\
* Each vtable index has an associated trampoline which dispatches to \
*   the IMP at that index for the receiver class's vtable (after \
*   checking for NULL). Dispatch fixup uses these trampolines instead \
*   of objc_msgSend.\
* Fragility: The vtable size and list of selectors is chosen at launch \
*   time. No compiler-generated code depends on any particular vtable \
*   configuration, or even the use of vtable dispatch at all.\
* Memory size: If a class's vtable is identical to its superclass's \
*   (i.e. the class overrides none of the vtable selectors), then \
*   the class points directly to its superclass's vtable. This means \
*   selectors to be included in the vtable should be chosen so they are \
*   (1) frequently called, but (2) not too frequently overridden. In \
*   particular, -dealloc is a bad choice.\
* Forwarding: If a class doesn't implement some vtable selector, that \
*   selector's IMP is set to objc_msgSend in that class's vtable.\
* +initialize: Each class keeps the default vtable (which always \
*   redirects to objc_msgSend) until its +initialize is completed.\
*   Otherwise, the first message to a class could be a vtable dispatch, \
*   and the vtable trampoline doesn't include +initialize checking.\
* Changes: Categories, addMethod, and setImplementation all force vtable \
*   reconstruction for the class and all of its subclasses, if the \
*   vtable selectors are affected.\
**********************************************************************/\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 The idea behind this is that the runtime is trying to store in this vtable the most called selectors so this in turn speeds up your app because it uses fewer instructions than
\f4\fs24 \cf5 \cb6 objc_msgSend
\f2\fs26 \cf0 \cb4 . This vtable is the 16 most called selectors which make up an overwheling majority of all the selectors called globally, in fact further down in the code you can see the default selectors for Garbage Collected & non Garbage Collected apps...
\f5\fs24 \
\pard\pardeftab720\sl440

\f4 \cf5 \cb6 static const char * const defaultVtable[] = \{\
    "allocWithZone:", \
    "alloc", \
    "class", \
    "self", \
    "isKindOfClass:", \
    "respondsToSelector:", \
    "isFlipped", \
    "length", \
    "objectForKey:", \
    "count", \
    "objectAtIndex:", \
    "isEqualToString:", \
    "isEqual:", \
    "retain", \
    "release", \
    "autorelease", \
\};\
static const char * const defaultVtableGC[] = \{\
    "allocWithZone:", \
    "alloc", \
    "class", \
    "self", \
    "isKindOfClass:", \
    "respondsToSelector:", \
    "isFlipped", \
    "length", \
    "objectForKey:", \
    "count", \
    "objectAtIndex:", \
    "isEqualToString:", \
    "isEqual:", \
    "hash", \
    "addObject:", \
    "countByEnumeratingWithState:objects:count:", \
\};\
\pard\pardeftab720\sl440

\f2\fs26 \cf0 \cb4 So how will you know if your dealing with it? You'll see one of several methods called in your stack traces while your debugging. All of these you should basically treat just like they are
\f5\fs24  
\f4 \cf5 \cb6 objc_msgSend()
\f5 \cf0 \cb4  
\f2\fs26 for debugging purposes...
\f4\fs24 \cf5 \cb6 objc_msgSend_fixup
\f5 \cf0 \cb4  
\f2\fs26 happens when the runtime is assigning one of these methods that your calling a slot in the vtable.
\f4\fs24 \cf5 \cb6 objc_msgSend_fixedup
\f5 \cf0 \cb4  
\f2\fs26 occurs when your calling one of these methods that was supposed to be in the vtable but is no longer in there
\f5\fs24  
\f4 \cf5 \cb6 objc_msgSend_vtable[0-15]
\f2\fs26 \cf0 \cb4 you'll might see a call to something like
\f5\fs24  
\f4 \cf5 \cb6 objc_msgSend_vtable5
\f5 \cf0 \cb4  
\f2\fs26 this means you are calling one of these common methods in the vtable. The runtime can assign and unassign these as it wants to, so you shouldn't count on the fact that
\f5\fs24  
\f4 \cf5 \cb6 objc_msgSend_vtable10
\f5 \cf0 \cb4  
\f2\fs26 corresponds to
\f5\fs24  
\f4 \cf5 \cb6 -length
\f5 \cf0 \cb4  
\f2\fs26 on one run means it'll ever be there on any of your next runs.
\f5\fs24 \
\pard\pardeftab720\sl440

\f2\b\fs26 \cf0 \
\pard\pardeftab720

\f5\b0\fs24 \cf0 \
\pard\pardeftab720\sl440

\f2\b\fs26 \cf0 Conclusion
\f5\b0\fs24 \
\pard\pardeftab720\sl440

\f2\fs26 \cf0 I hope you liked this, this article essentially makes up the content I covered in my Objective-C Runtime talk to the
\f5\fs24  {\field{\*\fldinst{HYPERLINK "http://cocoaheads.org/us/DesMoinesIowa/index.html"}}{\fldrslt 
\f2\fs26 \cf7 Des Moines Cocoaheads}} 
\f2\fs26 (a lot to pack in for as long a talk as we had.) The Objective-C Runtime is a great piece of work, it does a lot powering our Cocoa/Objective-C apps and makes possible so many features we just take for granted. Hope I hope if you haven't yet you'll take a look through these docs Apple has that show how you can take advantage of the Objective-C Runtime. Thanks!
\f5\fs24  {\field{\*\fldinst{HYPERLINK "http://developer.apple.com/mac/library/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html"}}{\fldrslt 
\f2\fs26 \cf7 Objective-C Runtime Programming Guide}} {\field{\*\fldinst{HYPERLINK "http://developer.apple.com/mac/library/documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html"}}{\fldrslt 
\f2\fs26 \cf7 Objective-C Runtime Reference}}
\f2\fs26 \
\pard\pardeftab720\sl440\sa260
\cf0 \
\pard\pardeftab720\sl440
\cf0 \
\pard\pardeftab720\sl440\sa220

\fs22 \cf0 Posted by Colin Wheeler at {\field{\*\fldinst{HYPERLINK "http://cocoasamurai.blogspot.com/2010/01/understanding-objective-c-runtime.html"}}{\fldrslt \cf7 3:53 PM}} {\field{\*\fldinst{HYPERLINK "http://www.blogger.com/email-post.g?blogID=34442452&postID=5434455288492319066"}}{\fldrslt \cf7 \'a0\'a0}}\
Labels: {\field{\*\fldinst{HYPERLINK "http://cocoasamurai.blogspot.com/search/label/CocoaHeads"}}{\fldrslt \cf7 CocoaHeads}}, {\field{\*\fldinst{HYPERLINK "http://cocoasamurai.blogspot.com/search/label/Objective-C"}}{\fldrslt \cf7 Objective-C}}, {\field{\*\fldinst{HYPERLINK "http://cocoasamurai.blogspot.com/search/label/Objective-C%20Runtime"}}{\fldrslt \cf7 Objective-C Runtime}}\
}